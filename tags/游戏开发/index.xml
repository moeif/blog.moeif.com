<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>游戏开发 on Meowsay</title>
    <link>https://blog.meowsay.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 游戏开发 on Meowsay</description>
    <image>
      <title>Meowsay</title>
      <url>https://blog.meowsay.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.meowsay.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 26 Mar 2023 15:44:52 +0800</lastBuildDate><atom:link href="https://blog.meowsay.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>角色扮演游戏设计艺术笔记</title>
      <link>https://blog.meowsay.com/posts/rpg-game-design-note/</link>
      <pubDate>Sun, 26 Mar 2023 15:44:52 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/rpg-game-design-note/</guid>
      <description>玩家需要感受到他们的交互效果，他们希望自己对游戏的经历起重要作用并通过他们交互对世界、故事或其他游戏元素产生某种程度上的辨认效果。
奖励 玩家在完成一次胜利，或特定的时候，给予一定的奖励，以此激励他们继续奋战。
保险性 确保玩家可以在游戏中通过某些途径获得物品，技巧等，以完成对于障碍的挑战。
确认 游戏规则不会确认，游戏的公平性保证
技巧 通过经历获得技巧。还需要明确地说明目标，让玩家知道为何而战。
铁杆（氪金）玩家需要 非常高级别的挑战 提供数小时扩展的游戏 某种程度的重玩结构 高度的细节和内存逻辑环境 使用字符、对象、符咒以及游戏设计的任何其他数字驱动等信息 普通玩家的需要 简单、简单、简单 短的学习曲线，游戏的界面和游戏的基本控制应该可以在短时间内掌握 非常快的升级速度以及频繁的奖励 以外观和感觉为中心的设计 清楚地提供游戏目标 短时间内应该能完成的游戏 破坏者的需要（特殊） 主要通过战斗解决游戏的目标 主要关注角色的战斗能力 探宝家式的玩家需要 频繁分布有价值的物品 具有找到便宜商品并且可以进行精明买卖的灵活的游戏经济系统 具有可以更多了解物品的组织属性和机制清单的系统 在模拟的经济系统中，有一些玩家会因为宝物的价值，或者艺术美而收集他们（收集癖好）。有一些物品不但非常有价值，而且可以帮助完成完成一些关键任务。玩家收集的许多材料的唯一的目标就是必须用它来做某些事情
旅行者的需要 可以探索的足够大的世界 很多交互细节 能够显示玩家到过和未到过的游戏地图 Q： 想办法处理冗长的背包物品列表，来找到需要的物品
随机性 随机性=冒险=危险=感情投入 游戏中的任何一部，都要让玩家明白有失败的可能性，任何一步都不能是100%确定的 例如攻击力，可以不用绝对攻击力，而使用范围。例如，攻击17~67
关于技能与角色特点（职业） 在网络游戏Ultima中，如果玩家一段时间没有使用某种技能的话，那么玩家的这种技能水平就会下降。使用这种方式，可以让玩家自己确定到底要保留哪些类型的技能。
还有一种方式，就是完全舍弃独立的技能系统，将所有的技能的载体放在物品（装备）上，例如一双靴子，有了这个，就拥有了垂直走路的能力。另一方面，因为这个能力的存在，所以这个靴子会占据较大的空间，或者让此物品很重，让玩家不能同时携带多于两个这类物品。
这种方案的有点是强制每个角色有不同的表现，并根据他们自己口袋装着的物品形成不同的角色。
经典RPG游戏中的重要因素 探险 让玩家处于一个令人难忘，错综复杂，但是具有内在致性的世界中。玩家在游戏中遇到的每个角色和每一件事情都应尽量真实，而还是为了迎合剧情发展。 故事 无论游戏中为玩家角色设计了什么大型剧情，我们一定要让玩家感受到游戏需要他们参与才能解决出现的那些问题。 战斗 令人兴奋、直觉、快节奏的战斗界面对游戏的成功是很重要的。 临时任务 拯救世界需要花费很多时间。要实现游戏的高度可重玩性，根据玩家角色的不同行为而提供不同的临时任务是一种好方法，这会让玩家们不断地重新开始。 搜寻财宝 玩家对于他们可以在盒子桶、板条箱，或者书箱里发现的东西非常好奇。任何看起来有可能包含报备的容器都会引起玩家的注意力，而正是我们游戏者决定他们过去会找到什么东西。我们可以为玩家提供武器、弹药、具有魔力的物品、珠宝，甚至是一件新衣服。不论提供什么，在玩家以后的游戏经历中，这些驼绒裤可以预约可以派上用场。要注意尽量避免创建无用的占是占据背包的物品。 资源管理 资源管理是RPG游戏的主要部分，通常会要求玩家管理一些琐碎的事务，比如保证角色具有足够吃的，保证足够的睡眠，保证武器处于战斗状态。由于某些物品的稀少或者难以获得，玩家还需要考虑使用情况，例如电池、子弹、血瓶等。RPG游戏通常也会让玩家自己去考虑如何花手头的钱，是去购买更好的装备，还是用来贿赂城堡卫兵。 解决问题 玩家在游戏过程中要面临多种类别的挑战，在战斗中随着遇到更厉害的怪物，玩家需要不断掌握新的策略。偶尔也会在黑暗的地下城和狂人住宅中遇到考验智力的难题和陷阱。 RPG游戏的持久力量在于超越了平凡的能力，可以将玩家带入兴奋和有趣的新设计，以家庭、城市、王国或者银河系的形式为玩家创造不同的机会。游戏中的每个人都有很重要的影响力。
游戏构思的可能选择 兴趣爱好 文化底蕴，探险 哲学、精神领域 历史事件 假定分析、推断 身边不断变化中的事情 公众会议、社会组织 自然规律 生命中出现的任何不寻常现象 军事训练准则 科技设备，中世纪武器，服装 玩家究竟是什么 一个玩家应当要做出选择 一个玩家应当要获得报酬 一个角色扮演游戏总是需要一些反对的力量去积极地对抗玩家。没有反对就没有斗争，而没有斗争你所拥有的就不是游戏了。 游戏规则 在一个RPG游戏中，你的任务就是去创建一套有着内在联系的规则，就像是棋子一样。你必须定义出玩家与他们的化身，与环境、目标，还有其他玩家及怪物相交互的所有方式。这当中有的规则是直接指出解决特定情况的方法，像是确定当当玩家试着踢到一扇门时将会发生什么情况。其他的规则都是普遍应用的一般性设计原则，它们可以帮助玩家了解游戏世界是怎样运行的。所有的这些想法必须平稳地结合在一起，从而创建出一个没有扣动、逻辑缜密的程序体，也就是人们所知道的规则体系。</description>
    </item>
    
    <item>
      <title>Unity 内存管理的专业提示</title>
      <link>https://blog.meowsay.com/posts/unity-memory-management-with-pro-tips/</link>
      <pubDate>Tue, 01 Nov 2022 10:04:23 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-memory-management-with-pro-tips/</guid>
      <description>优化是游戏开发中很重要的一部分，涉及的方面主要有 CPU，GPU，内存，网络等。
在这篇博客中，主要会写关于内存相关的优化，Unity 是如何管理内存的，以及怎样才能使游戏更高效地运行。
在深入到 Unity 之前，我们先来看一下内存是如何工作的。
操作系统会在物理内存的基础上，创建一个虚拟内存，用于程序运行。在这个抽象中，会有一些虚拟地址空间（VAS）
在内存优化上，主要考虑两部分，也就是栈（Stack）和堆（Heap）。在理解栈和堆之前，首先要理解在 Unity 中，数据的类型，可分为值类型，和引用类型。对于值类型的数值，会直接存储在栈上，并且是可以直接复制的。例如，int, float, bool, struct, Color Vector3 等。
而引用类型的数据，则是存储在堆上，但是，指向这个数据的指针，是存储在栈上的。
栈（Stack） 存储值类型 存储引用类型的指针 由 CPU 自动管理，无须程序员关心。在函数调用时，参数将自动申请内存放入栈中，当函数结束时，这些参数又会从栈取出，释放内存，这一切操作都是自动的。 栈比堆的速度快 栈的容量有限，如果超过上限，则会出现栈溢出。 栈的运行方式是 Last in first out。也就是后进先出，或者说先进后出。 堆（Heap） 可以存储引用类型和值类型的数据 由程序员手动管理 内存空间不一定是连续的 比栈速度慢 可以扩展空间大小 接下来，我们来理解什么是 “垃圾”，以及什么是 “垃圾回收”。
垃圾 存储在栈上的一个指向堆数据的指针结束时（释放时），堆上的数据没有用了，对于这样的对象，可以理解为 “垃圾”。
垃圾回收 为了解决垃圾内存的问题，.Net 有对应的垃圾回收系统。
在初始化一个新的进程时，语言运行时会为该进程保留一个连续的地址空间区域。这个保留的地址空间称为托管堆。托管堆维持指向堆中下一个对象的地址指针。
从托管堆中分配内存，比非托管堆中分配内存要快。
垃圾回收系统会创建一个包含从根可访问的所有对相的图。当一个对象不在这个图中，也就是无法从根节点访问时，垃圾回收系统会将这部分内存视为垃圾，并在合适的时机释放为其分配的内存。
Unity 的内存管理系统 Unity 的内存管理分为三部分。
托管内存 托管内存使用托管堆以及垃圾回收系统自动分配和释放内存，而提供这个功能的是 Mono 或 IL2CPP。在 Unity 中我们大部分时候使用的都是托管内存，所以 New 对象时，都不考虑释放，垃圾回收系统会帮我们处理掉。
C# 非托管内存 C＃非托管内存层使你可以在编写C＃代码的方便下访问本机内存层以微调存储器分配。
您可以在Unity Core API中使用Unity.CollectionsNamespace（包括NativeArray），以及Unity Collections软件包中的数据结构来访问C＃非托管的内存。如果您使用Unity的 Job System 或 Brust，则必须使用C＃非托管内存。</description>
    </item>
    
    <item>
      <title>异能觉醒，新游预约</title>
      <link>https://blog.meowsay.com/posts/new-game-to-reservation/</link>
      <pubDate>Mon, 17 Oct 2022 09:09:29 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/new-game-to-reservation/</guid>
      <description>4508年，因核泄露污染水域从而造成人类大灭绝，并造成了全球生物变异，但少数人类适应了污染，造成了细胞全面进化，使生命层次进化觉醒异能。
自从污染事件已来，整个世界变得异常的诡异，一些【奇奇怪怪】的东西，开始出现，什么鸡坤，什么篮球，杀伤力不强，但是让人异常头晕。在这个少数人的世界，开始一段令人哇塞的旅程。收集各种各样的物品，打造各种奇怪的装备，战斗各种让人费解的敌人。还可以养宠物，升级宠物，带着宠物去打怪……
一旦你开始玩这个游戏，奇怪的事情，就开始发生了……
是的，我又开发新游戏了，已经新建好文件夹，不过还没有开始写下第一行逻辑代码。
开发者的话 大家好，我是练习时长，好多年的，游戏开发者，因为技术太差，找不到工作，赚不到钱，只能白天送外卖，晚上开发游戏。我平时什么也不喜欢干，就喜欢打代码，做游戏。这个游戏，是我做的众多辣鸡，噢不，好玩的游戏之一。游戏正在开发中，预计下个月可以做完上线（如果我平时少摸点鱼的话），嗯，不管怎么样，点一下预约，点一下关注，你就是我爱的人~
虽然游戏还没有做完，但依然可以加入QQ号瞎聊【异能觉醒 - 1群】：134032407
游戏假图 游戏预约 在 TapTap 上预约：https://www.taptap.com/app/242377
在 好游快曝 上预约：https://www.3839.com/a/147738.htm</description>
    </item>
    
    <item>
      <title>通过作用域最小化来避免屎一样的代码</title>
      <link>https://blog.meowsay.com/posts/avoid-spaghetti-code-with-scope-minimization/</link>
      <pubDate>Tue, 04 Oct 2022 14:09:29 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/avoid-spaghetti-code-with-scope-minimization/</guid>
      <description>面条式代码，是软件工程中反面模式的一种，也就是源代码的控制流程复杂，混乱难以理解，见到来说，就是屎一样的代码。
最小化变量的作用域，是避免产生面条式代码的一种有效方式。
作用域最小化是一种构建代码的方式，操作起来很容易
声明具有最小作用域的变量 用具有最小作用域的数据来分配变量 事实上，是代码的结构，定一了变量的可见性。
背景 一个程序是由一些单一或者组合的语句构成，例如赋值操作、条件判断、循环等。
通常来说，如果有两个代码块 A 和 B
如果 A 包含 B，那么 A 就是 B 的外部代码块 如果 B 被 A 所包含，那么 B 就是 A 的内部代码块 代码的缩进级别，是由嵌套级别数量决定的，直接的内部块会比其外部块多一个级别。
我们假设定义全局作用域，也就是没有外部块的代码，缩进级别为0，而全局变量，就是那些在全局范围内定义的变量。
变量可见规则 一个变量的可见性，由下面规则决定
从该变量的声明语句开始 结束于变量声明块的末尾 并且在开始与结束中间的嵌套块中也是可见的 反过来说，如果一个变量是不可见的，那么
在变量声明前 在变量声明块结束后 建议 R1. 尽量不要使用全局变量 R2. 声明单一用途的变量 R3. 在接近变量用途的地方声明变量 R4. 保持小的代码块 R5. 使用靠近其声明的变量 R6. 使用不超过2层的嵌套 R1. 尽量不要使用全局变量 全局变量会使代码变得难以阅读和理解，难以维护和测试。
全局变量的使用，增加了出现问题的概率，并且不容易被发现。
程序中可能错误地分配变量的语句越少越好。
总之，全局变量的使用往往代表着技术债务，必须尽快重构以避免后期的不可维护。
R2. 声明单一用途的变量 为单一的特定目的声明和使用变量，以便将其作用域限制作到最小。
一个变量的目的性越多，意味着可访问此变量的代码块越多。
而变量可见的语句数量越多，可能错误地赋值变量的语句就越多。
可能错误地赋值变量的语句越多，那么发现和修复潜在错误就越困难。
R3. 在接近变量用途的地方声明变量 尽可能地在靠近将使用这些变量的语句和代码块的地方声明变量。
与 R2 严格相关。</description>
    </item>
    
    <item>
      <title>噪声函数与地图生成</title>
      <link>https://blog.meowsay.com/posts/noise-function-and-map-generation/</link>
      <pubDate>Sun, 25 Sep 2022 23:04:23 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/noise-function-and-map-generation/</guid>
      <description>在我学习声音信号处理的时候，我的大脑很自然地联想到了地图生成。这篇博客记录了关于信号处理的一些概念与地图生成相关的东西。这些知识点不是一些新的东西，但对我来说，是以前从未接触过的，所以我想记录一下，并且分享给大家。这篇博客会覆盖一些简单的主题，频率、振幅、噪声的种类、噪声的应用等。涉及到的数学部分，基本上只有正弦波形。
这里会从简单的概念开始，然后逐渐深入。
注意：下面涉及的代码，虽然是以 Python 来描述的（简单直观），但文章的目的是为了解释原理，使用任何语言都可以的。
1. 为什么随机性是有用的 我们在程序化的地图生成中要做的是生成一组输出，其中有一些东西是相同的，而有一些东西是不同的。例如，在我的世界这个游戏中，所有的地图都有很多相似性。生物群落，方块大小，生物群落的平均大小，洞穴的平均高度，不同石头所占的比例等等。但是，也有一些不同的地的：群落的位置，黄金的位置，洞穴的大小等等。作为游戏的设计者，需要决定哪些部分需要是相同的，哪些部分需要是不同的。
对于不同的部分，通常是使用随机数生成器。让我们来做一个极其简单的地图生成器：它将包含20个格子，其中某些格子将包含宝箱。结果如下 请注意这个地图有多少共同的地方：首先它都是由格子组成（每个点作为一个格子），每行有20个格子，然后有两种类型的块，一个是空白，一个是宝箱。
但有一点是不同的，哪一个格子是什么类型，也就是说宝箱可能出现在从0到19的任何一个格子。
我们可以使用随机数来选择将宝箱放在哪一个格子中。最简单的方式是选择从0到19的随机数。这意味着每一个格子都可能被选择。大部分的编程语言都包含随机数生成函数。在 Python 中，使用方式是 random.randint(0, 19)。完整代码如下
def gen() map = [0] * 20 pos = random.randint(0, 19) map[pos] = 1 return map for i in range(5): print_chart(i, gen()) 生成结果如下：
假设我们想让地图中的宝箱有更多的可能性出现在左边，这时就要使用非均匀随机数选择了。有很多方法可以完成这件事情，其中一种方式是首先选择一个随机数，然后将它向左移动，例如，使用函数 random(0,19)/2，下面是 Python 代码
def gen(): map = [0] * 20 pos = random.randint(0, 19) / 2 map[pos] = 1 return map for i in range(5): print_chart(i, gen()) 然后，如果我们想让宝箱更多地出现在左边，但是，右边也不能一个没有，应该怎么办呢？一个方式是使用平方数，也就是先选定一个随机数，然后计算它的平方，然后再用结果除以19(地图右边界索引)，得到的结果向下取整。下面是代码和效果
def gen(): map = [0] * 20 pos = random.</description>
    </item>
    
    <item>
      <title>Unity 游戏启动前显示隐私协议</title>
      <link>https://blog.meowsay.com/posts/show-privacy-before-unity/</link>
      <pubDate>Sun, 17 Jul 2022 06:04:23 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/show-privacy-before-unity/</guid>
      <description>使用 Unity 开发的游戏，在上架某些平台时，比如 TapTap，由于政策的原因，需要在收集用户信息，或使用某些权限时，先弹出隐私协议，用户同意之后，才能操作。但是如果直接在 Unity 里做这件事情，哪怕是用一个空场景来做，Unity 本身就会在隐私协议前收集一些信息，所以，我们需要使用原生代码，来操作这一块逻辑。这里只说 Android。
首先要做的就是在 Assets/Plugins/Android 新建一个 java 文件，用来作为启动 Activity，在这个 Activity 中，先展示隐私协议，当玩家点击同意后，再去调用 Unity 的 Activity。
package com.moeif.moeifgames; import android.app.Activity; import android.app.AlertDialog; import android.content.DialogInterface; import android.content.Intent; import android.content.SharedPreferences; import android.os.Bundle; import com.unity3d.player.UnityPlayerActivity; public class MoeNativeActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); if (!isTaskRoot()) { Intent intent = getIntent(); String action = intent.getAction(); if (intent.hasCategory(Intent.CATEGORY_LAUNCHER) &amp;amp;&amp;amp; action != null &amp;amp;&amp;amp; action.equals(Intent.ACTION_MAIN)) { finish(); return; } } Boolean anInt = false; // 隐私协议相关 SharedPreferences base = getSharedPreferences(&amp;#34;base&amp;#34;,MODE_PRIVATE); anInt = base.</description>
    </item>
    
    <item>
      <title>一个独立游戏的开发总结</title>
      <link>https://blog.meowsay.com/posts/a-indie-game-dev-summary/</link>
      <pubDate>Sun, 10 Jul 2022 11:04:23 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/a-indie-game-dev-summary/</guid>
      <description>从2021年4月开始，我作为一名独立开发者，开始了自己的瞎折腾之路。一年多没有做出什么赚钱的项目。不过现在，终于做出了一个对于我自己来说，算是成功的项目。
我现在上线的这款游戏是一个文字游戏，画风稀碎，也没有什么具体的游戏类型，一切都是野路子，只要觉某个玩法好玩，就会添加这个玩法。这个游戏就是《无量：钓海》，目前已经上线了 TapTap、好游快爆、AppStore、光环助手、4399 平台。在没有版号的情况下，国内也就这些平台可以上了。
《无量钓海》TapTap 链接: https://www.taptap.com/app/234065
游戏从构思，开发，到上线，经历了很多问题，也学到很多东西。这些经验，趟过的坑，开发上的积累，等等，都可以用于下一个项目。
这个项目参与的人可以说有三个。工程的开发，是我来做，游戏内容的构思，策划，是另一个小伙伴在做。第三个人，也是一个游戏玩法，帮我们做了一部分角色的图片。
这个游戏的起点，是在我一个游戏《游戏码农》的玩家群里，有一个玩家说他有一个很好的点子，建议我做一下。正好那个时候也在想新项目的方向，我考虑了一下，所性就问他是否愿意合作开发，然后游戏的广告收益进行分成。结果已经知道了，我们合作了。而这个玩家，是一个正在读高中的学生。在合作的过程中，一开始的沟通肯定不是那么顺畅的，因为对方也没做过游戏。但最终这个问题还是解决了，方法也很简单，就是把自己构思的东西，写明白，写详细，以文字的形式描述出来。至于工具，尝试了很多，最终他用起来最顺手的还是 WPS 云文档，那就这个了，毕竟工具而已，无所谓的。作为独立开发者，我觉得不要纠结于用什么工具，不要拿公司那套完善的流程来套用，可能并不合适。一定要记住目标，就是把游戏做出来，把构思内容传达明白，至于方式，在开始的阶段，根本不重要。当然，这只是从我个人的体验角度出发，如果意见不同，那就以你为准
游戏从构思，到上线，一共是两个半月的时间，前一个月，基本上没有工程开发相关的东西，也不是没有，只是没有游戏内容上的开发，那时我记得我好像在写热更新，广告调用，等等通用的东西。游戏一开始的构思方向，和现在上线的版本，差别还是挺大的，一开始构思的内容，除了核心的钓鱼这个点，其他的都推翻了。一开始挺慌的，不确定性太大了，策划心里可能也没谱，但还是这样做了，还好，这个方向也没啥大问题。
游戏在5.16号上线了 TapTap，好游快爆。建立了玩家 QQ 群，很快突破了2000人，TapTap 上的评分，也一路上涨，当然，这一切并不是因为游戏，而是我们在 QQ 群里说让大家评论，然后有兑换码奖励。这一点一定不要学，因为 TapTap 是不允许的。因为这个操作，游戏的评分从 4 分，2天内直接冲到了9分以上，并且进了热门榜前5。这也带来了大量的玩家加入QQ 群，为此我还给腾讯贡献了好几百块，用来充年度 VIP 会员，用来扩群。
不过给兑换码让玩家评论的方式，在 TapTap 这里是不允许的。后来，TapTap 就给我们发了警告，不过一开始我没有看到，所以导致了后面大量的评论被删，而且被删的都是一些好评，差评全都留下了，这直接导致了评分的腰斩，回到了6点几分。现在还好，慢慢的恢复正常了，稳定在 7 分左右。至此，游戏的前期平台流量，也基本上宣告结束了，每日下载量巅峰时刻是 1W 多，后来逐步下降，现在完全是自然量了，TapTap 平台每日新增玩家也就几十个，加上其他的平台，现在每日新增在 150 左右。目前累计玩家总量 4.9W 左右，我自己统计的，平台统计的可能会更多一点。每日活跃玩家总数大概是 1800 左右。
玩家 QQ 群人数多了，就会出现很多问题，很多人提各种建议，根本来不及做，只能先汇总下来，慢慢画饼。不过很多饼最终还是做出来了。另外，千万不要跟玩家硬杠，玩家觉得体验不好，自然有不好的道理，作为游戏开发者，要明白目标是什么，是赚钱（为爱开发，或者家里有矿的随便杠），一定要学会认怂。有一些玩家，玩的不爽了，没玩明白，反手就是 TapTap 上一个差评，而 TapTap 上的评评分，好敏感，可能几个差评就直接把分数拉下来了。所以，一定要学会认怂，和玩家硬杠，嘴上可能一时爽了，最终受损失的还是自己。另外，不要随便设置 QQ 管理员，设置了管理员，有一些管理员会觉得有权力了，但是有一些人不会真正站在游戏的角度考虑问题，会和玩家硬怼，因为管理员和游戏没有什么利益上的关系。玩家才不管这个人是不是游戏开发者，反手就是一个差评，受损失的还是游戏开发者。
为什么要以文字的形式来开发游戏呢？为什么不找人合作，将美术做的更好看一点呢？其实我也想啊，要是有一个亿，我也愿意组个团队去折腾，去尝试。可是现实是，对于独立开发者，最重要的还是要先活下去，有稳定的能够支撑基本生活的收入。文字游戏的开发周期，开发难度，是很小的，而文字的表现力，又是无限的。再就是找到合适的人，就很难，其次，风险很高，无法保证做出来一定有收入，还有分成问题，到底程序占多少，策划占多少，美术占多少，平均分配肯定是不合适的，还得根据不同的项目，工作量，来决定，前期分成如果没谈好，哪怕勉强做，可能后期效果，开发效率，也会有所影响。所以，并不是人越多，越好。
游戏从技术上采用了 xlua 热更新的方式开发的，所有的游戏逻辑都是用 lua 来写的，这带来了非常大的好处，我们可以快速的迭代版本，修改 Bug 等等。目前保持的节奏基本上是每天都会更新一点新内容。群里的玩家也养成了每天晚上8点等更新的习惯。如果技术上允许，建议大家使用这种方式，真的迭代很方便，资源上传 CDN 就可以。目前我用的 CDN 是 DogeCloud，新用户的话有免费的存储空间和流量，对于一个小项目来说，完全够用，目前我还没有把免费流量用完，连一半都没用上。
目前游戏的主要收益来自于两方面，一方面是广告，一方面是爱发电的赞助。至于赚了多少钱，从开发时间上来算，肯定没有之前打工时赚的多，不过还好有点收入。
游戏还在继续迭代，玩家的流量，也在缓慢减少，不过应该还能再持续一段时间。下一个项目，也在构思中了，敬请期待。
以上这些都是我从一个独立开发者的角度来谈的，无法和商业公司的开发模式去比较，仅仅是我所经历的一些东西。
技术交流，欢迎添加我的微信：ifloop</description>
    </item>
    
    <item>
      <title>让 Unity Shader 不受 Time.timeScale 的影响</title>
      <link>https://blog.meowsay.com/posts/unity-shader-unscaledtime/</link>
      <pubDate>Sat, 25 Jun 2022 11:04:23 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-shader-unscaledtime/</guid>
      <description>Time.timeScale 是 Unity 的时间缩放变量。如果将此设置为0，那么 Time.time 将停止，并且 Physics 和 Animator 在默认情况下也将停止。所以，将 Time.timeScale 设置为0，通常为了做暂停相关的东西。
但是，有时候希望即使将 TimeScale 设置为 0，有些东西也能继续运行，比如在写 Shader 时，经常会用到 _Time 属性，但是它会受到 Time.timeScale 的影响。不过有以下几种方式可以做到不受影响。
方法一 private void Update() { material.SetFloat(&amp;#34;_UnscaledTime&amp;#34;, Time.unscaledTime); } 这种方式比较直接，但是也有弊端，如果要设置的 Shader 很多，会增加很多 MonoBehaviour。
方法二 Unity 可以设置 Shader 全局变量，即材质之间共享属性。
private void Update() { Shader.SetGlobalFloat(&amp;#34;_UnscaledTime&amp;#34;, Time.unscaledTime); } 这样场景中只需要一个做这件事情的 MonoBehaviour 的脚本即可。这个方法可以覆盖大多数情况。
方法三 如果场景中不想放任何脚本，还有一个更强大的方法，那就是使用 PlayerLoop 来独立于 MonoBehaviour 更新全局属性。
首先引入一个工具类 PlayerLoopModifier.cs，代码如下
using System; using System.Collections.Generic; using System.Linq; using UnityEngine.LowLevel; public class PlayerLoopModifier : IDisposable { private PlayerLoopSystem root; public PlayerLoopModifier() { root = PlayerLoop.</description>
    </item>
    
    <item>
      <title>Lua 带权重随机</title>
      <link>https://blog.meowsay.com/posts/lua-randon-with-weight/</link>
      <pubDate>Fri, 03 Jun 2022 10:04:23 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/lua-randon-with-weight/</guid>
      <description>t 是数据数组，weights 是权重数组，两个数组长度是一致的。
function RandomWithWeight(t, weights) local sum = 0 for i = 1, #weights do sum = sum + weights[i] end local compareWeight = math.random(1, sum) local weightIndex = 1 while sum &amp;gt; 0 do sum = sum - weights[weightIndex] if sum &amp;lt; compareWeight then return t[weightIndex], weightIndex end weightIndex = weightIndex + 1 end return nil, nil end </description>
    </item>
    
    <item>
      <title>理解 Entity Component System</title>
      <link>https://blog.meowsay.com/posts/entity-component-system/</link>
      <pubDate>Sun, 03 Apr 2022 15:23:39 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/entity-component-system/</guid>
      <description>Entity-Component-System (ECS) 是一种架构模式。这种模式广泛地应用在游戏开发中。ECS 使用组合原则，因此这种模式使程序具有更好的灵活性和扩展性。游戏场景中的所有对象都被视为一个实体 (Entity)。这种模式在默认情况下也具有更高的性能。
Entity-Component-System 有三个部分组成
Entity (实体) Component (组件) System (系统) 什么是 Entity Entity 可以理解为一个对象的标识，它没有任何具体的数据和行为，只是标识一个东西。在实现上，通常可以用一个 Struct 来实现。而组件，为其提供数据。
例如，我们要实现一个太空版本 Minecraft，所有游戏中能看到的，有形的东西，都算作一个实体。一搜飞船，一个角色等等。
什么是 Component 组件是附加到实体的可重用模块，它是实体的单一行为描述。组件提供了实体的表现，行为，和功能。不同组件的组合，可以创造出不同类型的逻辑实体。
什么是 System 一个 System 在运行时会遍历很多组件，以此实现高效的性能。例如渲染，物理，寻路。系统为组件提代了全局的管理和服务。
我们可以使用系统来分离逻辑和数据，系统可以用来处理逻辑组件，充当数据容器。
关于系统的例子 处理重力加速度 将速度应用到一个向量上 根据 AI 的设计，来控制机器人的输入 渲染 (位置，Sprite) 处理玩家输入 组合 我们可以组合不同的 Component，以及设置 Component 不同的数据值，来配置具体的实体。
ECS 的优势 降低代码量以及复杂度 对于逻辑扩展拥有很高的灵活性 对于 3D 和 VR 需要大量渲染逻辑的项目有性能优势 让非技术人员更方便地编写脚本 可以分离庞大复杂的类结构 代码可重用和可组合性很强 更加方便的单元测试 可以支撑复杂的 VR 程序 运行时组件的替换 多进程和多线程友好 分离数据和功能 更加灵活地定义游戏对象 提供了解耦，封装，模块化，可重用性方法，以此构成一个干净的设计。 ECS 的劣势 不能像 MVC 那样直观定义逻辑 要用好 ECS，需要更多的思考组件的设计 ECS 需要写大量的小型代码，增加了出错的风险 目前的应用没有面向对象广泛 ECS 示例 看下面的图，这是一个兔子的实体，其中有很多组件被附加到了实体上，Placeable、Huggable、Consumable、Hopping 等 &amp;hellip;</description>
    </item>
    
    <item>
      <title>Unity 完整的热更新方案和流程</title>
      <link>https://blog.meowsay.com/posts/unity-hot-update/</link>
      <pubDate>Sun, 20 Mar 2022 12:30:42 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-hot-update/</guid>
      <description>在开发商业游戏时，热更新是一个很重要的模块，这里讲的热更新不是指仅仅修复Bug，而是进行游戏功能的更新。简单来讲，就是启动游戏后，跑个条，下载资源和代码，然后再进入游戏。本篇博客所写的内容并不是最优的解，只是完成了热更新这个事情而已，具体使用还需要使用者根据自己的项目来具体来看。
这里采用的方案是使用 AssetBundle 和 xLua。使用 AssetBundle 是为了资源的完全自主控制。而整个游戏的逻辑部分，则使用 xLua 来实现。当然，C# 的代码不可能一点没有，只是一些核心的功能模块，一般写好后就不会改变的东西，或者对性能要求很高的东西，放在 C# 就可以。
整个功能分为编辑器部分，和运行时部分。编辑器部分就是编 Bundle，生成版本文件等。而运行时部分就是从 CDN 下载版本文件，对比版本号及本地资源是否有要更新的，如果有，则更新，更新完后进入游戏。没有，则直接进入游戏。
编辑器部分 编辑器部分主要就是生成 Bundle 文件，首先，我是按目录来划分 Bundle 的，任何一个目录下的文件（不包括子目录）则会打成一个 Bundle。例如下面的目录结构
Res/ - ConfigBytes/ - UI/ - LuaScripts/ - Data/ - ItemsData/ - CharactersData/ 首先 Res 目录是资源的主目录，下面有各种子目录（Res 目录下不会有需要打 Bundle 的文件）。ConfigBytes 目录下的文件，会打成一个 Bundle。UI 目录下的文件会打成一个 Bundle。LuaScripts 目录下的文件会打成一个 Bundle。Data 目录下的 ItemsData 目录中的文件会打成一个 Bundle，Data 目录下的 CharactersData 目录会打成一个Bundle。如果 Data 目录下存在文件（非目录），则这些文件会打成一个 Bundle。简单来讲，就是会按文件夹来决定哪些文件打成一个Bundle，检查的时候只会取一个文件夹下的文件，而不会递归取这个文件夹下的子目录。
LuaScripts 目录在开发时会放在 Assets 目录外面，与其同级，在编 Bundle 时，会拷贝 LuaScripts 目录及下面的所有文件，按原有目录结构，拷贝到 Res 目录中，并且会将每一个 xxx.lua 文件的扩展名改为 xxx.</description>
    </item>
    
    <item>
      <title>一个游戏兑换码生成及验证方案</title>
      <link>https://blog.meowsay.com/posts/exchange-code/</link>
      <pubDate>Tue, 01 Mar 2022 13:00:42 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/exchange-code/</guid>
      <description>在开发独立游戏《小镇危机：来自丧尸的问候》时，需要设计一个兑换码的功能，但是在网络上也没有找到合适的方案，所以这里就自己考虑了一种。这里会说明思路，具体的实现，可以按照自己的方式去定制。
我们的游戏中有两种资源可以兑换，一种是星星，一种是钻石。所以就需要在兑换码中通过某种方式表示出来。本质上就是将自己想兑换的数据，通过某种方式的变换，隐藏在兑换码中，然后服务器是知道解码方式的，通过解码，即可还原出玩家兑换的是什么，然后将兑换物品回给玩家。
我们的游戏兑换码为14位的，里面包含的信息有兑换类型，兑换数量，这两个信息，例如 LMA60XV7380QBH。
1. 兑换码生成和验证过程 兑换码由大写字母和数字组成，对于兑换码中的每一个字符，我们可以使用的字符为 [0, 9] 和 [A, Z]。 确定要表示的信息，所占用的字符数。对于我们的游戏来说，兑换类型只需要 1 个字符即可，而兑换数量，需要占用 4 个字符，到此，已经消耗掉 5 个字符。 兑换码的数据校验和，会占用2个字符，到此消耗掉 7 个字符。 剩下的 7 个字符，为唯一的随机字符串，用于填充验证码的。 根据上面的步骤，首先生成第 3 步所需要的 7 位随机字符串。由于我们每一位可用的字符数是36个，所以最终的排列组合有上百亿种，我们不需要那么多，几百万个足够了。这里要注保证唯一性。生成的字符串如下所示
DLDWVEQ WM8YB8M MNUP5RR 3RG7X8D VUBPD8J J3L3ZR1 1Y1ALB3 R6PRATR 然后表示出兑换码要兑换的数据，假设这里要兑换星星，并且兑换的数量为 10000 个。首先使用一个字符来表示星星，例如使用 S 来表示，当然，也可以将 36 个字符进行分组，然后从组中去随机一个，这样更不容易被破解。然后兑换的数量，可以转为 16 进制，或者 34 进制都行。假设这里使用 34 进制来表示，10000 转为 34 进制就是 8M4，不足4位，前面进行补0，也就是 08M4。进制转换的逻辑需要自己写。
取一个随机字符串，与要兑换的信息进行组合，组合的方式随意，只要最后恢复时使用相同的方式即可。假设这里将随机字符串的前3位放在兑换码的开始，然后跟上兑换类型，后三位放在最后。这里使用上面第一个随机字符串为例子。经过这一步组合，得到的字符串如为 DLDS08M4WVEQ。
然后计算上面得到的字符串的校验和，为 AD，将 AD 放在最后，这里随意，可以按自己想放的位置去放，自己知道就好了。现在得到的字符串为 DLDS08M4WVEQAD。
最后需要做的就是将上面得到的字符串进行打乱，按什么样的方式打乱呢，这里需要事先生成几套排列方案，例如 [8, 1, 5, 9, 2, 4, 0, 12, 7, 10, 13, 11, 3, 6]，也就是字符中第一个字符放到索引 8 的位置，第二字符放到索引 1 的位置，第三个字符放到索引 5 的位置，以此类推。我们可以生成多套这样的排列方案，然后使用字符串中的其中一位，来表示，例如我们使用第2位的L来表示使用哪一套方案，将 L 转换为 int 数值，然后对排列套数进行 % 操作，得到使用哪一套排列方案，进行排列。这里要注意，第2位不能变，也就是不受随机排列影响，忽略掉，否则服务器没法恢复。</description>
    </item>
    
    <item>
      <title>我的独立游戏下载量和广告收入情况</title>
      <link>https://blog.meowsay.com/posts/coder-game-ad/</link>
      <pubDate>Sun, 06 Feb 2022 17:00:42 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/coder-game-ad/</guid>
      <description>经过了几个月的开发，我的游戏终于上线了。这篇博客来聊一下目前这个游戏的下载量和广告收入情况。
《游戏码农：那些打工的日子》是一个轻松的模拟经营文字游戏，游戏的主角是一个普普通通的小码农，刚刚来到一线城市，开始自己的职业打工生涯。游戏拥有丰富的玩法，轻松的升级体验，多种不同的赚钱方式，实现财富自由，指日可待。
目前已经上线 AppStore，TapTap，好游快爆等平台。
AppStore: https://apps.apple.com/cn/app/id1607035933
TapTap: https://www.taptap.com/app/230651
好游快爆：https://www.3839.com/a/141332.htm
下图是 Android 平台的广告收入情况 下图是 iOS 平台的广告收入情况 通过上面的广告收数据可以知道，从 2022.01.27 到 2022.02.05 这几天，Android 平台一共收入了 111 块钱，而 iOS 共收入了 70 块。
下面是各个渠道的下载量统计 从上线以来，目前总玩家数有2982，期中日活玩家平均不到200。在渠道统计中有一个为 Development 的渠道，占了总玩家数的大部分，但是，这个渠道的包不是我发的，而是被破解了广告的一个包，所以其实真正导致收入的玩家数，是很少的。
综上，这个游戏从玩法上来说，玩家粘性一般。从收入上来说，也是几乎可以忽略了。假设包没有被破解，可能收入会翻倍，不过那也没多少，和之前打工时的工资，根本无法比。
萌一小栈 欢迎关注微信公众号 萌一小栈，博客文章同步推送 </description>
    </item>
    
    <item>
      <title>游戏码农：那些打工的日子</title>
      <link>https://blog.meowsay.com/posts/coder-game/</link>
      <pubDate>Fri, 04 Feb 2022 23:00:42 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/coder-game/</guid>
      <description>经过了几个月的开发，我的游戏终于上线了。
《游戏码农：那些打工的日子》是一个轻松的模拟经营文字游戏，游戏的主角是一个普普通通的小码农，刚刚来到一线城市，开始自己的职业打工生涯。游戏拥有丰富的玩法，轻松的升级体验，多种不同的赚钱方式，实现财富自由，指日可待。
目前已经上线 AppStore，TapTap，好游快爆等平台。
AppStore: https://apps.apple.com/cn/app/id1607035933
TapTap: https://www.taptap.com/app/230651
好游快爆：https://www.3839.com/a/141332.htm
找工作 游戏开始需要完善简历信息，然后选择中意的公司进行投递和面试，拿到 Offer 后，不同的公司，给出的薪资略有差距，需要仔细考虑。
租房子 压一付一的租房模式，大大缓解了刚开始打工的年轻人，到底是住的远一点，舒服一点，便宜一点。还是住的近一点，老破小，还贵。
点外卖还是自己做饭 自己做饭，需要先购买食材，然后根据菜谱来做，挑战很大，但是成本低。点外卖，省力，就是花钱有点多。
学习 想要提高自己的专业经验，光打工是不够的，还得多多学习。
休息 在家里的时候，可以打打游戏，看看小说，睡睡觉，打工也是一个长期的活，同时也要照顾好自己噢。
通勤 打车很舒服，消耗体力也小，坐地铁便宜，但是人挤人，应该怎么选择呢？似乎还得看看自己的存款
上班 认认真真完成工作，也别忘记偶尔摸个鱼，或者钱很多可以把自己的工作任务偷偷外包给同事。
投资 光靠打工是很难实现财富自由的，还是投资吧，股票、基金、贵金属等等，多种投资模式自己选择，真实的市场波动。
资产 有些东西可能平时用不着，但是很贵。
赚钱小游戏 偶尔休闲一下，打两把小游戏，顺便赚点钱，当然，也可能输。
萌一小栈 欢迎关注微信公众号 萌一小栈，博客文章同步推送 </description>
    </item>
    
    <item>
      <title>Gameplay 02 游戏中的跳跃</title>
      <link>https://blog.meowsay.com/posts/gameplay-02-jump/</link>
      <pubDate>Sat, 22 Jan 2022 20:50:49 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/gameplay-02-jump/</guid>
      <description>游戏中的跳跃，就是以某一个速度起跳，克服重力。而以不同的速度，起跳的最高点是不一样的，很难去量化，所以我们可以定义每次起跳的最大高度，然后求出起跳速度，即可做到一切可控。
自由落体公式 $h = \frac{1}{2}gt^2$。速度 $v = gt$，这个是瞬时速度，但是自由落体的速度是均匀变化的，所以平均速度就是下落高度中间时刻的速度，所以才得出 $h = \frac{1}{2}gt^2$。
我们的目标是求出跳跃的速度。
首先，假设我们以一个初始速度 $j$ 来跳跃，这个是一个向上的速度，但是因为重力的存在，所以我们的跳跃速度会因为重力的向下抵消，而逐渐趋向于 0。当 $j$ 慢慢被抵消到 0 时，我们也就达到了以 $j$ 这个速度来跳跃所能到达的最大高度。
对于任意时刻 $t$，速度 $v = j - gt$，当 $j - gt = 0$ 时，也就是我们所能到达的最大高度。所以，到达最大高度的时间为 $t = \frac{j}{g}$。
根据上面的公式，我们可以知道，在以 $j$ 来跳跃的整个过程中，任意时刻的高度为 $h = jt - \frac{gt^2}{2}$。
由于我们上面已经知道了，在 $t = \frac{j}{g}$ 时，我们将达到最大跳跃高度。将 $\frac{j}{g}$ 带入到任意时刻的高度公式中 $h = jt - \frac{gt^2}{2}$。我们可以得到 $h = j(\frac{j}{g}) - \frac{g(\frac{j}{g})^2}{2}$。
化简上面的公式将得到 $h = \frac{j^2}{g} - \frac{\frac{j^2}{g}}{2} = \frac{j^2}{g} - \frac{j^2}{2g} = \frac{j^2}{2g}$。</description>
    </item>
    
    <item>
      <title>Gameplay 01 游戏开发中的平滑移动</title>
      <link>https://blog.meowsay.com/posts/gamedev-smooth-move/</link>
      <pubDate>Thu, 06 Jan 2022 20:11:49 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/gamedev-smooth-move/</guid>
      <description>这篇博客，聊一聊在游戏开发中，控制角色或者其他物体的平滑移动。现实中，一个物体，从静止加速到匀速运动状态，或者从匀速运动状态变为静止状态，都会有一个过程。就像人走路，或者汽车开动。
一个物体在运动状态下，会有一个速度变量，也就是我们期望的速度。而从静止到运动状态的过程，会有一个加速度。
而游戏开发中，要做到一个物体平滑的运动，也就是模拟出这个从静止，通过加速度，达到期望速度的过程。
游戏是按帧运行的，在初始的时候，目标运动速度为0，随着每一帧的流逝，目标速度会不断累加一帧中的加速度，当累加到期望速度时，则会以期望速度来运动。
代码如下，这里是在 Unity 中实现的，但是原理对于所有游戏引擎通用
using System.Collections; using System.Collections.Generic; using UnityEngine; public class MovingSphere : MonoBehaviour { // 用户设定最大期望速度 [SerializeField, Range(0f, 100f)] private float maxSpeed = 10f; // 用户设定最大加速度 [SerializeField, Range(0f, 100f)] private float maxAcceleration = 10f; // 当前的运动速度 private Vector3 velocity; // Update is called once per frame void Update() { // 通过读取用户输入，来确定期望速度向量（向量包含了大小和方向） Vector2 playerInput; playerInput.x = Input.GetAxis(&amp;#34;Horizontal&amp;#34;); playerInput.y = Input.GetAxis(&amp;#34;Vertical&amp;#34;); Vector3 desiredVelocity = new Vector3(playerInput.x, playerInput.y, 0.</description>
    </item>
    
    <item>
      <title>编译 Apple Silicon 版本 Aseprite</title>
      <link>https://blog.meowsay.com/posts/compile-aseprite-for-apple-m1/</link>
      <pubDate>Wed, 01 Dec 2021 21:12:47 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/compile-aseprite-for-apple-m1/</guid>
      <description>&lt;p&gt;编译苹果 M1 芯片版本的 Aseprite，步骤如下&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《音乐与僵尸：Zombie Rhythm》开发日志</title>
      <link>https://blog.meowsay.com/posts/zombie-rhythm-devlog/</link>
      <pubDate>Tue, 12 Oct 2021 12:43:47 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/zombie-rhythm-devlog/</guid>
      <description>&lt;p&gt;《音乐与僵尸：Zombie Rhythm》经过了一个多月的开发，终于上线了。这是一个融合了丧尸和音乐节奏的休闲游戏。这篇文章就聊一下这个游戏的整个开发过程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《我在美国学游戏设计》笔记</title>
      <link>https://blog.meowsay.com/posts/game-design-note/</link>
      <pubDate>Mon, 27 Sep 2021 15:35:42 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/game-design-note/</guid>
      <description>&lt;p&gt;从情感体验出发，探索出最合适的机制来表达情感。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何开发一个问答类游戏</title>
      <link>https://blog.meowsay.com/posts/how-to-make-a-quiz-game/</link>
      <pubDate>Sun, 29 Aug 2021 12:19:40 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/how-to-make-a-quiz-game/</guid>
      <description>问答类游戏，在开发过程中还算是比较简单的一个分类，核心的内容就是问题与答案。抽象来讲，问题可能是文字，也可以是图片，也可以是声音等等，而对应玩家可以选择的答案，也可以不同的表现形式。例如看电影海报猜电影名字，听音乐片段猜歌曲等等
【诗仙与诗魔】，是一个诗词挑战类游戏，本质上也算是一个答类游戏，问题变成了某一首诗中的某一句，而答案就是从给定的类似诗句中选择正确的那一句。接下来我将从技术有角度来解析一下这个游戏的整个开发过程。
这个游戏现在可以直接从商店下载体验，在 AppStore 或 TapTap 搜索 诗仙与诗魔 即可找到。
这个游戏现在可以直接从商店下载体验，在 AppStore 或 TapTap 搜索 诗仙与诗魔 即可找到。
iOS 下载连接: https://apps.apple.com/app/id1583234447
Android 下载连接: https://www.taptap.com/app/222178
先解析一下这个游戏，诗仙与诗魔有三种玩法，独自练习，就是关卡模式。无尽冲榜，就是不断地累积得分，然后进行排行榜。匹配挑战，是可以与其他玩家进行联网匹配的玩法，这一个涉及到服务器部分的开发。
客户端的部分 客户端在启动后，会先去一个固定的域名，拉取一些必要的配置信息，例如服务器的状态，排行榜和匹配服务器的连接地址，服务器的状态等等。这个可以自己根据需求配置各种各样的信息，只有这些必要的信息拉到后，游戏才会继续下一步。
接下来会从本地尝试读取用户数据，如果本地没有，则会从服务器尝试请求，如果服务器也没有，则认为这是一个新玩家。弹出玩家昵称输入界面，玩家确定后，会将用户的ID和昵称等数据发到服务器，并且在本地存档，然后就会进入游戏。如果本地没有用户数据，但是服务器有，就会使用服务器保存的用户数据，进行数据恢复，然后在本地存档。
接下来就进入了主界面，可以选择三种不同的玩法。先说一下诗词数据。诗词数据是使用 flatbuffers 存储在游戏包里的。每一个记录，保存了一首诗的ID，名字，作者，内容等。游戏启动后，会读取所有的诗词数据，进行结构化存储。每一首诗，会创建一个 Poem 对象，里面保存了这首诗的内容，以及额外的数据，例如这首诗有几句，每一句的字数，这些数据会用于随机生成问题，以及根据字数，从其他诗词中选择类似的诗句，用作答案。
关卡模式，就是罗列出诗词配置表中的每一首诗，作为一个关卡，当玩家作答完毕后，会记录所用时间。在关卡界面，所以看到每一首作答过的诗词所用的时间。
无尽冲榜，首先进入时会消耗体力，对于每一个新玩家，会给予默认300体力，还有2个复活道具，5个刷新道具。在冲榜模式中，每一首诗会有10秒的倒计时，在过程中，玩家可以选择使用一个刷新道具，换一首诗作答，以此不终断冲榜过程。冲榜结束后，会给出得分，客户端会得得分提交到服务器。对于头衔，是由得分计算出来的，这个直接在客户端计算。游戏没有作作弊方面的处理，对于这个游戏来说，没什么必要。如果失败，则必须消耗一个复活道具，才能继续从失败的地方继续冲榜。如果道具或体力不足，则可以通完看广告获得。
匹配挑战，匹配挑战同样会消耗体力，进入后，首先会向服务器发送匹配消息，服务器会在根据匹配的等待时间，根据玩家的 elo 分值，进行实力相当的匹配，如果最后没有真实玩家，则会匹配一个机器人，与玩家一起玩。每一局匹配挑战由10首诗构成，由哪10首诗，以及每一首诗的可选择答案，则由服务器生成，以此保证两个玩家使用的挑战数据是一致的，保证公平性。
匹配挑战的分得计算，每一首诗为1000分，如果答错，则0分。如果答对，先得500分，剩下的500分，根据作答速度，剩余时间的百分比，进行得分。得分由服务器计算，一定程度上受网络影响。
服务器的部分 服务器可以分为三部分，服务器及用户基础数据，排行榜，匹配，这三部分是使用不同的方式实现的。
服务器及用户基础数据 这一部分使用 aws 的 DynamoDB、Lambda、 API gateway 实现的。通过API gateway 调用 lambda 读写 DynamoDB的数据，可以根据网上一些视频教程来操作来下。逻辑很简单，主要是配置各种权限的时候稍微麻烦一点，也还好。
排行榜 排行榜放在了 aws 的免费 ec2上，因为游戏的量不大，所以免费的也够用，数据直接放在了 Redis 中，API 逻辑是使用 Rust 来写的。
匹配 匹配部分也是放在 aws 的免费 ec2 上。也是使用 Rust 写的。连接模块使用了 message-io 的 websocket。客户端和服务器使用了简单的 json 交互，因为数据比较简单，就没有使用更复杂的协议。期中，匹配开了两个线程，一个用于监听客户端的连接，收到连接后，会将连接数据发往另一个线程，数据的交互是使用了 rust 的 channel。游戏管理器收到新的连接，就会加入到客户端的列表。收到客户端发来的消息后，会进行解析，然后进行逻辑处理。</description>
    </item>
    
    <item>
      <title>Unity 2D 游戏背景适配</title>
      <link>https://blog.meowsay.com/posts/unity-2d-bg-adaptive/</link>
      <pubDate>Sun, 22 Aug 2021 20:57:04 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-2d-bg-adaptive/</guid>
      <description>&lt;p&gt;在开发2D游戏的时候，不同的设备分辨率下，经常需要将背景以高或以宽来适配。如果以高适配，即背景图的高度填充整个屏幕，然后去缩放宽度。最终效果图如下&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unity Sprites Full-Rect 和 Tight 设置</title>
      <link>https://blog.meowsay.com/posts/unity-sprite-full-rect-tight/</link>
      <pubDate>Sat, 21 Aug 2021 15:27:38 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-sprite-full-rect-tight/</guid>
      <description>&lt;p&gt;在开发2D游戏的时候，对于图片的 Mesh Type 设置我们应该选择 &lt;strong&gt;Full Rect&lt;/strong&gt; 还是 &lt;strong&gt;Tight&lt;/strong&gt; 呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unity 接入 Topon 报错解决</title>
      <link>https://blog.meowsay.com/posts/solve-topon-ad-build-error/</link>
      <pubDate>Sun, 25 Apr 2021 20:16:59 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/solve-topon-ad-build-error/</guid>
      <description>&lt;p&gt;最近在接入Topon广告聚合SDK是，导出XCode工程后，编译报了一堆错误，搞了好久，这里记录一下解决过程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unity XCode 自动设置签名</title>
      <link>https://blog.meowsay.com/posts/unity-xcode-auto-signing/</link>
      <pubDate>Fri, 12 Mar 2021 19:01:01 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-xcode-auto-signing/</guid>
      <description>&lt;p&gt;Unity ios导出XCode工程后，通常需要手动设置签名，就像下图中的样子。只要简单的两部设置，就可以自动选择我们想要的签名。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unity 接入 Sigmob SDK</title>
      <link>https://blog.meowsay.com/posts/sigmob-sdk-for-unity/</link>
      <pubDate>Wed, 06 Jan 2021 22:03:56 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/sigmob-sdk-for-unity/</guid>
      <description>&lt;p&gt;在 Unity 项目中接入Sigmob 时，遇到很多问题，他们的文档写的也不是很清楚，特别是对于 Android 开发没有很深入了解的情况，读起来很困难，这篇博客记录了详细的 Sigmob 广告 sdk 接入过程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>理解 Boids</title>
      <link>https://blog.meowsay.com/posts/understanding-boids/</link>
      <pubDate>Mon, 30 Nov 2020 18:01:00 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/understanding-boids/</guid>
      <description>Boids 可以理解为类似鸟群的东西，就是多个个体之间的相互作用。在游戏开发中经常会用到。例如 RTS 游戏，控制一个坦克战队，如何保持行进方向的一致性，以及坦克之间互相有一定有间隔，又不会间隔太大，这里就可以使用 Boids 相关的理论来实现。
在众多这方面的文章中，基本上会涉及到三个方面，跟随、分离、聚合。跟随，就是说整个群体有一个行进的大方向。分离，则是个体与个体之间有一定的间隔，不至于发生碰撞。而聚合，就是个体不能离群体太远，不能脱离群体。
对于上面提到的三个方面，简单来说，就是一个力的叠加。
跟随 一个鸟群往哪个方向飞，可以假设有一只领头的鸟，其他的鸟跟随这只鸟的方向。知道领头的鸟的方向，知道自己当前的飞行方向，就可以计算出应该向中个方向施加一个力，可以使自己的方向，偏向于领头的鸟的方向。
分离 分离，是要保证个体之间不要离的太近，不要发生碰撞。先考虑两个物体的情况，假设要使物体 A 远离物体 B，只要从 B，向 A 施加一个推力，就可以将 A 推离 B。那如果 A 要同时和 B 与 C 保持距离呢？一样的，只需要从 B 和 C 分别向 A 施加一个推力，这两个的合力，就是 A 远离 B 和 C 的方向。同理，不管 A 要与多少个物体保持距离，只需要从每个物体出发，向 A 的方向施加一个力，就可以将 A 推开。
上面只考虑了 A 远离其他物体的情况，如果每一个物体都要与其他物体保持距离呢？一样的，只需要从每一个其他物体，向自己的方向施加一个力，这个合力，就是自己运动的方向。
聚合 为了保证个体不脱离群体，还需要一个聚合力。就是将个体自身，推向群体中心的力。
分离的力和聚合的力一定程度上抵消，从而达到个体之间即保持了距离，又保证了每一个体不脱离群体。
下面的代码是我的一个小游戏项目中的，其中只用到了分离和聚合。只要懂了原理，就可以根据具体的情况灵活变通，达到自己想要的效果即可。
using UnityEngine; using System.Collections.Generic; using System.Collections; public class GamePlayFlock : MonoBehaviour { public static List&amp;lt;GamePlayFlock&amp;gt; flockList = new List&amp;lt;GamePlayFlock&amp;gt;(); public static void StartAllFlock() { for(int i = 0; i &amp;lt; flockList.</description>
    </item>
    
    <item>
      <title>Apk 上架前的签名操作</title>
      <link>https://blog.meowsay.com/posts/apk-signature/</link>
      <pubDate>Thu, 05 Nov 2020 14:09:29 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/apk-signature/</guid>
      <description>&lt;p&gt;在 APK 包上传到一些应用市场时，通常要求开发者对 APK 进行签名，下面记录一下签名步骤。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unity 接入友盟SDK</title>
      <link>https://blog.meowsay.com/posts/unity-umeng-sdk/</link>
      <pubDate>Sun, 16 Aug 2020 10:56:24 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-umeng-sdk/</guid>
      <description>友盟游戏统计 SDK 可以很方便的统计一些游戏数据。使用他们的自定义事件，来统计自己项目关心的数据。现在接入 SDK 已经比以前方便了很多，不需要再导出 Android 工程去修改 Java。下面将一步一步详细说明。
要使用友盟 SDK，一共有以下几步
在友盟后面新建应用 在友盟后面建立自定义事件 下载并导入 SDK 调用 SDK 1. 在友盟后面新建应用 首先注册账号，然后进入友盟工作台。↓ https://www.umeng.com/
然后点击上面的产品，移动统计 ↓
点击添加应用 ↓
然后填写应用信息，下面是我随便填的，根据自己的应用信息填写即可（随便填也没关系）↓
点击注册后，将跳到下面的页面，这里我们只要关注这个 AppKey 即可，其他的不用管。这个 AppKey 会在 Unity 中用到 ↓
2. 自定义事件 建立好了应用后，就要想好我们想要统计哪些数据。例如，有多少用户点了开始游戏，有多少用户点了 观看广告，有多少用户观看广告结束，等等，这些都可以统计。
所谓的统计，也就是使用自定义的事件名，在不同的地方调用一下友盟的代码。所以接下来我们就建立自己想要统计的数据事件。
在应用页面，点击我们刚才新建的应用 ↓
然后依次点击 设置 -&amp;gt; 事件 -&amp;gt; 手工添加 ↓
我们下面先定义一个统计游戏开始的事件，事件 ID 是这个事件的唯一表示，会在 SDK 调用时用到，显示名称是让我们自己知道这个事件是干嘛的。然后点击确定 ↓
添加完后的事件，会显示在事件列表中。接下来我们再添加一个统计事件，例如游戏结束。↓
现在我们已经有了两个事件，当然，还可以添加更多，统计更多数据。这里为了演示，就只添加两个。↓
3. 下载并导入 SDK 建立好了事件，就可以在项目中使用了，首先要将友盟的 SDK 导入工程中。去友盟的 SDK 页面下载 SDK https://developer.umeng.com/sdk/u3d，这里我们下载 Unity3D 的。
下载下来的是一个 ZIP 压缩包，解压后，依次找到里面的 Unity3D -&amp;gt; analytics -&amp;gt; analytics_unit3d_x.</description>
    </item>
    
    <item>
      <title>游戏项目资源管理</title>
      <link>https://blog.meowsay.com/posts/u3d-game-resources-managemant/</link>
      <pubDate>Sat, 25 Apr 2020 18:57:08 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/u3d-game-resources-managemant/</guid>
      <description>在游戏开发的过程中，整个项目的资源管理是很重要的一部分。涉及到与美术、策划等同事的协作，以及资源的打包，和后续运行时资源的更新，加载，卸载，内存管理等方面。规划好资源的的各个目录存放，以及资源的分类，会为后续的开发工作节省不少时间。这一篇博客主要来聊一下到资源的存放问题，而 AssetBundle 打包，以及运行时的更新和资源管理，将在后面的博客中详细说明。
资源类型 一个游戏项目，涉及到的资源主要有 配置数据、图片、模型、材质、Shader、字体、音频、视频、动画Clip、Prefab、Animator Controller、Timeline、场景文件、Lua脚本 等。
关于协作 首先说一下协作问题。在游戏开发的过程中，美术的同学需要将资源直接提交到建立好的项目中的指定目录中，一般来说，提交到哪个目录，是由程序的同学来决定，具体哪个目录，要根据后续的资源打包以及管理等方面决定。美术的同学提交的资源一般就是模型、动画、贴图等。
而配置数据，则通常由策划同学来提交。配置数据的方式有很多种，常用的例如 Excel，有的项目是直接将原始的 Excel 文件放到工程中，而有的是将 Excel 数据转成其他格式再放到项目中。改表由策划同学来着手操作，在配表的过程中，除了数值，可能也会涉及到一些资源路径，例如有一些图片，是要动态加载的，那么路径也就配在某个模块的相关配置表中。而这些路径配在表中的资源，通常也由策划同学根据不同的系统来操作资源的位置。当然，首先会有一个父目录，在这个父目录下，策划的同学可以自由操作资源的位置，然后将资源的路径配置在数据表中。
还有一个很重要的部分是UI，对于UI来说，如果不打图集，放入项目目录中的都是一个一个的散图，则可以由UI部分的同学直接将UI的图提交到指定的UI父目录下，父目录下的子目录，根据不同的模块来划分，共用的同可以放到一个公用的目录中。对于图的移动操作，都要在 Unity 中进行操作，防止 Prefab 上的图片引用丢失。如果UI使用 TexturePacker 这类工具打成一张图集，则可以由程序同学来做，在开发某个模块时，顺便将对应UI的图打成一张图集，原始的UI图就不必放到工程中，放在外部的一个美术的资源目录即可。
资源存放 接下来，就说一下各个资源怎么去划分。在运行时，需要手动加载的资源，一般有下面这些，Prefab、图片、音频、视频、动画Clip、Animator Controller、配置数据 等，Prefab 这个不用多说。而图片，主要是UI上的一些动态的图，例如头像，或者其他一些需要根据数值，来显示不同的图。动画Clip 可以做成动态加载，也可以直接放到动画状态机中，根据实际情况决定。Animator Controller 也要根据情况决定。配置数据一般需要动态加载。而像 Prefab中用到的材质，贴图等，一般不需要我们手动加载，我们只需要加载 Prefab 即可。
这些需要动态加载的资源，我们可以放在一个父目录下，例如这个目录就叫 Prefabs，然后在 Prefabs 下面建立各个子目录，或者多级子目录来存放不同的资源。如下图
上面的图中只是大概划分了一下，每一个目录下，都可以再次建立子目录，子目录下还可以再细分子目录，具体还需要根据实际项目来划分。
上面图中的目录，是用于存放那些我们需要动态加载的资源，还有一些不需要我们动态加载的资源，例如美术同学上传的原始FBX，以及模型使用到的材质，贴图等等。对于这些资源，我们可以再建立一个目录，例如叫做 RawResources。在这个目录下，我们也需要清晰地去划分子目录，要清楚地知道哪一个目录放了什么资源，哪一些 Prefab 会引用这些资源，后面写 Bundle 打包模块时，可能会用得到。
关于 AssetBundle 问题 在打包 AssetBundle 时，Unity是可以自己处理依赖关系，例如我们可以不用管 RawResources 中的东西，只把 Prefabs 目录下的资源打包，而Prefab引用的原始资源，例如贴图，材质等，会自动打进Bundle，不需要我们手动管理。但是这样有一个问题是，对于共用的资源，会造成重复包含。看下面的图
上面的图中，两个 Prefab 引用了同一个材质，而材质，引用了一张贴图。如果我们将 PrefabA 和 PrefabB 分别打成一个Bundle，而让 Unity 自己处理依赖打包关系，那么就会出现 PrefabA 所在的 Bundle 中包含了材质和贴图，而 PrefabB 所在的 Bundle 中，也包含了材质和贴图。这样就造成了 Bundle 文件占用空间变大，在运行时，占用内存变大。</description>
    </item>
    
    <item>
      <title>Unity Shader | 半兰伯特、高光反射、BlinnPhone</title>
      <link>https://blog.meowsay.com/posts/unity-shader-basis-05/</link>
      <pubDate>Thu, 19 Mar 2020 21:50:16 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-shader-basis-05/</guid>
      <description>写 Shader，到底是在做什么？Shader 就像一个拥有魔法的黑箱，我们最终从它那里得到的，是像素的颜色。而得到的是什么样的像素颜色，则取决于我们丢进黑箱里的是什么东西，以及使用的魔法咒语是什么。丢进同样的东西，使用不同的魔法咒语，得到的像素颜色也是不一样的。输入顶点的坐标，光线方向，以及自定义的颜色，使用不同的计算方式，得到的像素颜色是不一样的。使用同样的计算方式，丢进一个纯色颜色值，和丢进一张纹理，得到的像素，也是不一样的。
如果把整个 Shader 比作一个函数，那么顶点位置，自定义的颜色值，纹理，灯光等这些就相当于函数的输入参数，而 Shader 中写的各种计算，用的各种算法，都是对输入的那些参数进行操作，而最终生成的，就是颜色值，也就是相当于函数的返回值。把 Shader 想的简单一点，就是输入需要的东西，进行计算，得到像素值。
这篇博客，还是关于光照模型的，接下来我们首先总结一下常用的光照模型。
Lambert (兰伯特) 光照模型 在之前的博客中说了漫反射的实现，实现漫反射用到的模型，叫做 Lambert (兰伯特) 光照模型。Lambert 实现出来的效果，一旦入射光向量与材质表面的角度大于90度，那么得到的漫反射颜色就会全部变为黑色，没有任何明暗变化效果。
Lambert 光照模型公式: 最终颜色 = 直射光颜色 * 漫反射颜色 * max(0, dot(光源方向, 法线方向))
其中，直射光颜色，漫反射颜色，都是我们自定义的变量。
Half Lambert (半兰伯特) 光照模型 Half Lambert 是在 Lambert 模型的基础上，做了微调，也就是将光源方向与法线方向的点乘结果，从原来[-1, 1]，映射为 [0, 1]，这样原来背光面，也会有明暗效果。
Half Lambert 光照模型公式: 最终颜色 = 直射光颜色 * 漫反射颜色 * (dot(光源方向, 法线方向) * 0.5 + 0.5)
Specular (高光反射) 这里的高光反射使用了 Phone 模型，的原理很简单，想象一束光射向某个点，然后反射出去，我们的眼睛同样看向那个点，当我们的眼睛看向那个点的方向，与光线反射的方向，越接近时，进入我们眼睛的反射光则越多，也就是更亮。看下面的图
很明显，当视野方向与光的反射方向夹角越小时，也就是说进入眼睛的光越多，所以那个点也就会越亮，这就是高光反射的原理。所以高光反射，实现起来也就很简单了，只要拿到视野方向，拿到直射光的反射方向，就可以求出最终的颜色值。
Specular 光照模型公式: 最终颜色 = 直射光颜色 * 反射光颜色 * pow(max(0, dot(反射光方向, 视野方向)), 光泽度(gloss)) + 漫反射颜色 + 环境光颜色</description>
    </item>
    
    <item>
      <title>Unity Shader | 光照模型和漫反射</title>
      <link>https://blog.meowsay.com/posts/unity-shader-basis-04/</link>
      <pubDate>Sun, 15 Mar 2020 11:54:30 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-shader-basis-04/</guid>
      <description>在之前的文章中写的Shader，呈现出来的物体样子是一个平面2D的状态，即使物体是3D的，那是因为，我们还没有将灯光加入到Shader的运算中。现在，我们将介绍灯光相关的东西，最后呈现出和 Unity Diffuse Shader 一样的效果。
什么是光照模型 光照模型，简单理解就是一种运算，或者说一个公式，计算的结果，决定了一个点受到光照时，所表现出来的效果。例如，光照在木板上，和照在一面镜子上，我们所看到的效果是不一样的，照在镜子上，很大一部分光会被镜子反射，而木板，却不会反射那么多光。
进入摄相机的光线分类 在游戏中，我们可以将进入摄相机的光分为 高光反射、漫反射、自发光等。像上面说的镜子反射了大部分光，就是高光反射，现实中比较光滑的表面，受到光照时，都会产生这种效果，很亮。而光线照在木头上，就是漫反射，其实是木头先吸收了光，然后向周围散射出去，这个就不会很亮。而自发光，就是字面意思，自身是一个发光体。这里大概知道这些词是什么就可以，不必深究里面的原理。
这一篇博客，接下来我们将在Shader中实现一下漫反射。实现漫反射，可以在顶点函数中，这叫做逐顶点光照。也可以在片元函数中实现，这叫做逐片元光照。在顶点函数中实现，也就是对每一个顶点都进行一次光照的计算，而在片元函数中也就是对每一像素执行光照计算，所以，在片元函数中实现相对来说要更耗费一点性能。
在顶点函数中实现漫反射 漫反射的计算公式是 最终颜色=直射光颜色 * max(0, dot(光线，法线))，也就是使用 Directional Light 的颜色 乘 光线发射方向 与顶点法线方向的夹角，dot函数就是点乘，结果就是夹角。有一点要注意的是，dot中的 光线 和 法线 都是单位向量，也就是我们要对其进行标准化。max函数是取最大值，也就是说，如果dot计算出来的结果小于0，那就取0。
看下面的代码，注意看注释，从上往下每一个注释都要看
Shader &amp;#34;iMoeGirl/04-DiffuseVertex&amp;#34; { SubShader { Pass { // 要使用光照，首先要定义一下LightMode，这里我们使用ForwardBase， // 这里先不用管意思，只要照着写上就行 Tags { &amp;#34;LightMode&amp;#34; = &amp;#34;ForwardBase&amp;#34; } CGPROGRAM // 这里我们将 Unity 一些预定义的Shader代码包含进来， // 里面有我们需要的东西，场景中第一个Directional Light的信息（后面用来做计算） #include &amp;#34;Lighting.cginc&amp;#34; #pragma vertex vert #pragma fragment frag // 根据共识，要计算最终顶点的颜色，需要法线数据，所以这里将法线从Application传到顶点处理函数中 struct a2v { float4 vertex: POSITION; float3 normal: NORMAL; // NORMAL就是法线语义，之前的文章说过 }; struct v2f { float4 position: SV_POSITION; fixed3 color : COLOR; // 这个颜色就是在顶点函数中计算完的顶点的漫反射颜色，传到片元函数中 }; // 把光照的计算放在顶点函数中，所以叫做顶点光照 v2f vert(a2v v) { // 定义一个数据传送结构体（传送到片元函数中） v2f f; f.</description>
    </item>
    
    <item>
      <title>Unity UGUI RGB通道分离抖动</title>
      <link>https://blog.meowsay.com/posts/unity-ugui-tiktok-effect/</link>
      <pubDate>Sun, 08 Mar 2020 22:18:03 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-ugui-tiktok-effect/</guid>
      <description>&lt;p&gt;今天我们要在 UGUI 上实现图片RGB通道分离抖动效果，先看最终效果图&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unity Shader | 使用Struct传递数据</title>
      <link>https://blog.meowsay.com/posts/unity-shader-basis-03/</link>
      <pubDate>Sat, 07 Mar 2020 14:02:26 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-shader-basis-03/</guid>
      <description>上一篇博客 说了在 CGPROGRAM 中写代码、顶点处理函数、片元处理函数、以及在两个函数之间传递简单的数据、从 ShaderLab 属性到CG数据类型之间的联系等。这一篇博将稍详细一点说一下 Shader 的基本知识，以及在顶点和片元函数之间传递更多的数据。
Shader的基本理解 简单来说，Shader 决定了一个模型最终呈现在屏幕上的样子。一个模型由很多顶点构成，而每一个顶点，都会经过 Shader 中的顶点处理函数，这个过程，就是从应用将数据传递到顶点处理函数，顶点函数需要将顶点从模型空间转换到屏幕空间，或者说是裁剪空间，也可以简单理解为从 3 维空间转换到屏幕上的 2 维空间。在这个过程中，还可以做一些其他对顶点的操作。
顶点数据经过顶点处理函数处理后，接下来就返回，然后传给片元处理函数，到了这一步，面对的，就是像素，也就是每一个像素的颜色值。在这里，可以根据自己的需求，对每一个像素做处理，例如做高斯模糊，RGB通道分离，等等，各种各样的效果。
向 Shader 传递更多的数据 在之前的博客文章中，我们只是将顶点的坐标传给了Shader，但是我们还需要其他的数据，例如法线，例如切线，纹理坐标等等。接下来，我们将使用结构体来存储要传递的数据，看下面的代码
Shader &amp;#34;iMoeGirl/03-Shader&amp;#34; { Properties { _MainColor(&amp;#34;颜色类型&amp;#34;, Color) = (1,1,1,1) } SubShader { Pass { CGPROGRAM float4 _MainColor; #pragma vertex vert #pragma fragment frag // 这里定义一个结构体，封装需要从应用传到顶点函数的数据 struct a2v { float4 vertex : POSITION; // 顶点坐标 float3 normal : NORMAL; // 顶点法线 float4 textcoord : TEXCOORD0; // 第一套纹理坐标(可以有多套) }; // 这里定义另一个结构体，封装从顶点函数传到片元函数的数据 struct v2f { float4 position : SV_POSITION; float3 temp : COLOR0; }; // 顶点处理函数，传入的是a2v结构体，返回的是要传到片元函数的v2f结构体 v2f vert(a2v v){ v2f result; result.</description>
    </item>
    
    <item>
      <title>Unity Shader |  属性、顶点与片元函数</title>
      <link>https://blog.meowsay.com/posts/unity-shader-basis-02/</link>
      <pubDate>Mon, 02 Mar 2020 22:46:56 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-shader-basis-02/</guid>
      <description>上一篇博客 介绍了Shader的基本结构，这里我们继续来说Shader的编写，也就是要在 CGPROGRAM 中写代码。首先我们把之前的Shader结构代码复制过来。
Shader &amp;#34;iMoeGirl/MyShader&amp;#34; { // Shader 名字 // 这里定义一些属性，可以显示在UI面板上用于调节 Properties { // 属性名(&amp;#34;Inspector面板上显示出来的属性名&amp;#34;, 属性类型) = 默认值 _Color(&amp;#34;颜色类型&amp;#34;, Color) = (1,1,1,1) _Vector(&amp;#34;向量类型&amp;#34;, Vector) = (1, 2, 3, 4) _Int(&amp;#34;整型&amp;#34;, Int) = 11111 _Float(&amp;#34;浮点型&amp;#34;, Float) = 12.11 _Range(&amp;#34;范围类型&amp;#34;, Range(100, 1000)) = 128 _Tex2D(&amp;#34;贴图类型&amp;#34;, 2D) = &amp;#34;white&amp;#34;{} _Cube(&amp;#34;立方体贴图类型&amp;#34;, Cube) = &amp;#34;white&amp;#34;{} _Tex3D(&amp;#34;3D纹理&amp;#34;, 3D) = &amp;#34;white&amp;#34;{} } // 子 Shader，可以写多个，显卡运行时， // 从第一个SubShader开始，如果第一个里面的效果都支持，则使用第一个， // 如果发现这个SubShader里面某些效果不支持，则自动运行下一个SubShader SubShader { // 至少有一个Pass，相当于一个方法 Pass { // 在Pass块里写Shader代码 CGPROGRAM // 使用 CG语言编写Shader ENDCG } } // 如果发现所有的SubShader都不支持，则使用Fallback，相当于后备方案 Fallback &amp;#34;VertexLit&amp;#34; } 怎样使用 Properties 中定义的属性 Unity3D定义Shader属性所使用的语法，和CG所使用的说法是不一样的，所以我们要在一个Pass中使用Properties中定义的属性，需要在Pass中再以CG的语法再写一遍，其实就是变量名相同，而数据类型不同，在Shader在编译的时候，就会自动将两个变量关联起来。看下面的代码</description>
    </item>
    
    <item>
      <title>Unity Shader | 基础</title>
      <link>https://blog.meowsay.com/posts/unity-shader-basis-01/</link>
      <pubDate>Mon, 24 Feb 2020 22:14:04 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-shader-basis-01/</guid>
      <description>MeshFilter 存储一个Mesh（网格，模型的网格，模型的三角面顶点信息）
MeshRenderer 用于渲染一个物体的外观，数据来源于MeshFilter
Material 材质包含两部分，贴图和Shader
OpenGL DirectX 直接与显卡交互图形渲染库，可以理解为应用程序与显卡之间的桥梁，为应用程序提供一些渲染接口，用于渲染。
Shader Shader可以理解为是一种渲染命令，由opengl或DX进行解析，用于控制图形的渲染。
GLSL/HLSL/CG shader编程语言，GLSL面向OpenGL，HLSL面向DirectX，CG是Nvidia公司出的，跨平台的shader编程语言。
ShaderLab 我们在Unitiy中写Shader用的语言是ShaderLab，可以理解为Unity为了方便使用者写Shader而创造的一种新的Shader语言，最后其实都会在底层被翻译成GLSL或HLSL或CG。
Unity中的Shader分类 Shader的中文名叫做着色器
表面着色器，Surface Shader 顶点/片元着色器，Vertex/Fragment Shader 固定功能着色器，Fixed function Shader (在现代硬件上基本已被弃用) 表面着色器可以理解为是对顶点/片元着色器的一种封装，它帮我们处理了很多渲染上比较麻烦的事情。而顶点/片元着色器就相对更灵活一些，也就是说很多东西要自己处理，相对来说要写的代码更多一些。进一步讲，使用顶点/片元着色器能实现的效果，使用表面着色器并不一定能实现，或者说，并不一定那么方便地实现。
Unity Shader 结构 Shader &amp;#34;iMoeGirl/MyShader&amp;#34; { // Shader 名字 Properties { // 这里定义一些属性，可以显示在UI面板上用于调节 } SubShader { // 子 Shader，可以写多个，显卡运行时， // 从第一个SubShader开始，如果第一个里面的效果都支持，则使用第一个， // 如果发现这个SubShader里面某些效果不支持，则自动运行下一个SubShader } // 如果发现所有的SubShader都不支持，则使用Fallback，相当于后备方案 Fallback &amp;#34;VertexLit&amp;#34; } Unity Shader 属性类型 Shader &amp;#34;iMoeGirl/MyShader&amp;#34; { // Shader 名字 // 这里定义一些属性，可以显示在UI面板上用于调节 Properties { // 属性名(&amp;#34;Inspector面板上显示出来的属性名&amp;#34;, 属性类型) = 默认值 _Color(&amp;#34;颜色类型&amp;#34;, Color) = (1,1,1,1) _Vector(&amp;#34;向量类型&amp;#34;, Vector) = (1, 2, 3, 4) _Int(&amp;#34;整型&amp;#34;, Int) = 11111 _Float(&amp;#34;浮点型&amp;#34;, Float) = 12.</description>
    </item>
    
    <item>
      <title>使用 Unity 实现漂亮的数学曲面(下)</title>
      <link>https://blog.meowsay.com/posts/unity-basis-03-math-curve2/</link>
      <pubDate>Thu, 16 Jan 2020 15:51:00 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-basis-03-math-curve2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://imoegirl.com/2020/01/10/unity-basis-03-math-curve1/&#34;&gt;上一篇博客&lt;/a&gt;我们实现了一些简单的数学曲面，这一节我们将继续更复杂的数学曲面展示，所有资源完全承接上一篇内容。&lt;/p&gt;
&lt;h2 id=&#34;25-创建一个涟漪效果&#34;&gt;2.5 创建一个涟漪效果&lt;/h2&gt;
&lt;p&gt;先来看一下最终要实现的效果图&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;我们一步一步来实现这个效果。首先，要创建一个基于到原点距离正弦波。而这个距离，我们使用毕达哥拉斯定理也就是勾股定理 $a^2 + b^2 = c^2$ 。对于这个效果来说，我们是基于XZ坐标来求Y坐标的，所以也就是 $\sqrt{x^2 + z^2}$ 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Unity 实现漂亮的数学曲面(上)</title>
      <link>https://blog.meowsay.com/posts/unity-basis-03-math-curve1/</link>
      <pubDate>Fri, 10 Jan 2020 10:51:45 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-basis-03-math-curve1/</guid>
      <description>这篇博客是上一篇 使用Unity3D展示Sin函数动画 的续篇，在上一篇的基础上，来实现更复杂的效果。在文章最后会有完整的 C# 代码和 Shader 代码，先来看一下最终的效果图
由于篇幅太长，所以将分为上下两部分，现在开始第一部分的内容。
先将上一节 使用Unity3D展示Sin函数动画 的资源准备好，可以按下面的步骤手动建立，也可以直接导入上一节内容的完整 Unity 资源包，点这里下载
使用Unity的Cube做成一个Prefab 新建一个 Shader，命名为 ColoredPoint，Shader 的代码为上一篇博客的 Shader 新建一个材质，命名为 ColoredPoint，并使用第2步中创建的Shader C# 逻辑代码，也使用上一篇博客中的完整代码，在本文中会有很多修改 接下来，我们开始新的内容。
1 在不同的效果函数之间切换 在上一篇博客中我们实现了Sine函数的展示，现在要加入更多函数的展示，为了方便在运行状态可以随时切换到其他函数，我们需要把每一种类型的展示放在独立的函数中。
1.1 将 Sine 函数的表示放在独立函数中 首先在 Graph 脚本中添加一个新的函数 float SineFunction(float x, float t) {}，这个函数将用于展示 $f(x,t) = sin(π(x + t))$。然后我们需要将函数体的内容填写进去，代码如下
float SineFunction(float x, float t) { Mathf.Sin(Mathf.PI * (x + t)); } 然后把 Update 函数里的代码改为调用我们新添加的函数
void Update () { for (int i = 0; i &amp;lt; points.</description>
    </item>
    
    <item>
      <title>使用Unity3D展示Sin函数动画</title>
      <link>https://blog.meowsay.com/posts/unity-sine-visualization/</link>
      <pubDate>Mon, 06 Jan 2020 13:05:08 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-sine-visualization/</guid>
      <description>&lt;p&gt;今天我们要实现的东西，就是下面这个动图的效果。使用代码控制方块的坐标，来展示 &lt;code&gt;Sin&lt;/code&gt; 函数。方块的颜色变化，是随着坐标变化而动态改变的，我们会写一个超简单的 &lt;code&gt;Shader&lt;/code&gt; 来实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>制作一个会动的时钟</title>
      <link>https://blog.meowsay.com/posts/unity-basis-01-clock/</link>
      <pubDate>Mon, 06 Jan 2020 11:02:32 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-basis-01-clock/</guid>
      <description>这是 Unity 基础系列教程的第一篇博客。我们将由浅入深，一步一步学习Unity及游戏开发相关的东西。整个系列教程所使用的Unity版本为 2018.4 及以上就可以，如果要使用特殊版本，则会在文中指出。
今天要做的是一个能够实时显示当前时间的时钟，就是下面这个东东。
1 首先建立一个新工程 首先打开Unity，创建一个新工程，名字自己定，例如 Clock 就可以。默认打开后，Unity 默认布局是下面图的样子。
你也可以更新布局，例如换成同时显示View和Game视图的布局，只需要点击编辑器最右上角的那个按钮，然后选择 2 by 3 即可成为下面图的样子。
下面是分辨率的设置，一般游戏开发中，会使用一个基准分辨率，很多游戏采用的是 16:9 的模式。这个在 Game 视图中设置，看下面的图，选择 16:9 即可
1.1 创建一个 GameObject 默认的场景中，会包含两个 GameObject，一个是主相机 MainCamera， 一个是灯光 Directional Light。这两个东西保持默认就好，现在我们创建一个新的物体，在 Hierarchy 面板右键，然后 Create Empty，或者通过菜单栏 GameObject/Create Empty都可以，这样就会在Hierarchy 面板上看到我们新建的物体，然后对这个物体重命名为 Clock，并且把它的位置置为 (0,0,0)。看下面的图
1.2 创建时钟的表盘 创建表盘，我们使用 Unity 默认的物体 Cylinder，然后改变它的大小，使其成为我们的表盘。首先，通过右键 Hierarchy 空白处，或者通过菜单栏 GameObject 中的 3D Object/Cylinder 选项，来创建一个 Cylinder，就是一个圆柱体。
Cylinder 默认已经有了很多组件，Mesh Filter、Capsule Collider、MeshRenderer。默认我们不需要物理模拟方面的东西，所以我们先把 Capsule Collider 这个碰撞器给删掉，通过右键这个组件，Remove Component 即可。
然后我们改变园柱体的大小，因为表盘是一个圆盘形状的东西，所以我们把圆柱体压平，也就是改变y轴的大小始可。把圆柱体 Scale 设置为 (10, 0.1, 10)，如下图。</description>
    </item>
    
    <item>
      <title>梦开始的地方</title>
      <link>https://blog.meowsay.com/posts/a-game-project-0-start/</link>
      <pubDate>Sun, 08 Dec 2019 14:44:42 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/a-game-project-0-start/</guid>
      <description>经历过很多项目，遇到和解决过很多问题，但是没有没有以文字的形式总结过。所以这个系列，我打算从客户端的视角，去总结一个游戏项目从开始到上线，整个过程中的一些事情，人员之间的配合，客户端一些重要模块的实现，开发过程中遇到的问题等等。
一个项目的开始，可能始于某一个人的某一个微小的想法，经过一段时间的构思，然后到达公司层面，在经过很多人的会议讨论，市场调研，等等，觉得方案可行，然后就是立项，准备进入开发阶段。这个过程不是一两天完成的，可能经历了很长时间。这个阶段，也会大概预计项目周期，项目成本，什么时候上线，盈利情况预估等等。
一旦确认了项目开发，策划方面会先行，进行项目的具体设计，开会讨论，确定方案等等。
然后美术也会根据项目的方向，做一些可以看的东西，可能这些东西最终不会进到版本中，但是现阶段是需要的。
至于程序呢？这个阶段可能就开始搭框架了，做一些与具体游戏逻辑没有太大关联的，框架层面的模块，例如资源管理啦，网络通信啦，等等。
这个阶段可能会持续一段时间，然后就会逐渐进入更加规范和流程化的游戏逻辑开发。不同的程序写不同的游戏模块。
在前期开发过程中，可能会有很多东西做出来了，然后效果不太好，就被砍掉了，或者整个设计变化很大，基本上等于这个模块推到重来，这都是很正常的情况。不管是美术，策划，和程序，都会有这种情况发生，不过随着游戏的开发进度，这种情况会越来越少。
从开发到上线，游戏会经历很多测试版本，可能有公司内部测试版本，外部小规模测试版本，外部大规模测试版本，付费测试版本等等。每一次版本测试，都会得到很多信息，用于调整和改善游戏内容。经过几轮测试以及测试后的版本打磨，整个项目会越来越接近上线版本。
当然，在一切顺利的情况下，游戏最终会提交上线。然后就是后期的运营，以及上线后的版本迭代，内容更新，Bug 修复等等。
这大概就是一个游戏项目的完整生命周期。</description>
    </item>
    
    <item>
      <title>浅谈Unity3D音频可视化效果原理</title>
      <link>https://blog.meowsay.com/posts/unity-audio-visualization/</link>
      <pubDate>Wed, 04 Dec 2019 16:08:42 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-audio-visualization/</guid>
      <description>&lt;p&gt;在游戏开发中，你是否也想将音乐旋律变为漂亮的图形显示？就像这样的效果。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>怎样在Unity中Reload原生插件</title>
      <link>https://blog.meowsay.com/posts/reload-native-unity-plugins/</link>
      <pubDate>Sun, 01 Dec 2019 01:05:25 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/reload-native-unity-plugins/</guid>
      <description>这是一篇翻译文章，原文来自 how-to-reload-native-plugins-in-unity
在Unity编辑器使用原生插件，Dll之类的，经常会遇到一个问题，替换插件时，Unity会提示正在使用，无法替换，这是因为Unity一旦点了Play，加载了Dll，就不会去卸载。
要解决这个问题也很简单，那就是先关掉Unity，然后替换Dll，然后再打开Unity。对于插件的使用者，倒不是什么大问题，但是如果你是插件的开发者，需要频繁的修改和测试插件，那就有点悲惨了。
这篇博客将介绍一个我认为不错的解决方案，有很多开发者已经实现了这个或者类似的解决方案，但是在Google或者Github上很难找到。
TLDR 我写了一个200行的代码，在OnAwake时，会加载所有的Dll，在OnDestroy时会卸载所有的Dll，我们自己去管理Dll的加载和卸载，就可以做到停止Play时，卸载掉所有的Dll，这样就可以在不关闭Unity的情况下，替换Dll。
要做到这个，就不能用 PInvoke 去调用，而是用类似的方式，达到相同的目的。
完整的工程代码在 Github。但是我们只需要一个文件就可以 NativePluginLoader.cs
如何使用: 将 NativePluginLoader.cs 放到你的工程中
在场景中新建一个GameObject，然后挂载 NativePluginLoader.cs
定义一个类，用于声明所有的插件方法，例如命名为 FooPlugin，然后给这个类赋予 PluginAttr 属性
给 delegate 添加 PluginFunctionAttr 属性，示例代码如下
// C# 代码 [PluginAttr(&amp;#34;my_cool_plugin&amp;#34;)] public static class FooPlugin { [PluginFunctionAttr(&amp;#34;sum&amp;#34;)] public static Sum sum = null; public delegate float Sum(float a, float b); // 原生方法的 delegate } void CoolFunc() { float s = FooPlugin.sum(1.0, 2.0); } // 这里是原生C代码中的接口, 最后打成Dll给Unity调用 // my_cool_plugin.h extern &amp;#34;C&amp;#34; { __declspec(dllexport) float sum(float a, float b); } 关于 PInvoke 调用原生插件的常规方法是通过 PInvoke</description>
    </item>
    
    <item>
      <title>浅谈在Unity3D中使用CriWare播放声音</title>
      <link>https://blog.meowsay.com/posts/unity-criware/</link>
      <pubDate>Sat, 30 Nov 2019 19:17:25 +0800</pubDate>
      
      <guid>https://blog.meowsay.com/posts/unity-criware/</guid>
      <description>在游戏开发中的音频解决方案，CriWare 是不错的选择，很多游戏大作也在使用。为什么使用CriWare呢？对于游戏运行时，可以显著提高加载速度和减小包体大小。而对于音频制作上，可以很方便地做更多的效果，例如多音源的避让等。
今天我们就来浅浅地聊一下在 Unity3D 中使用 CriWare 播放声音，以及声音的管理等问题。
音频文件由做音频的同学使用CriWare的软件去制作，最终导出的文件是以acb或awb为扩展名的文件。如果采用的是Memory的形式，则导出的acb文件。
对于开发来说，首先要知道两个东西，一个是CueSheet，一个是CueName。在音频制作的时候，多个音频可以打成一个组，每一个音频的名字，就是CueName，而这个组，就是CueSheet。我们要播放一个声音，首先要知道声音的名字，就是CueName，还要知道它所在的组，因为要加载到内存中。即使要播放组中的一个音频，也是要把整个组加载到内存中的。
所以在制作时，音频那边的同学要规划好，哪些音频要在同一个组，哪些音频要在另外的组。当然，可以一个音频一个组，但是打成组可以做很多事情，这个等我请教一个音频那边的同学再补充。
先将声音播放出来 首先把CriWare插件导入到Unity中
将做好的声音ACB文件放入StreamingAssets目录中
新建一个空物体，然后挂载CriAtom组件如下图
CriAtom 用于管理CueSheet，只有将CueSheet加入到CriAtom中，才能播放其中的某一个音频。将CueSheet加入到CriAtom中，意味着这个CueSheet会被加载到内存中，移除CueSheet，则会从内存中卸载。
上图中每点击 Add CueSheet，就可以填入一个新的CueSheet，Name字段就是ACB文件的名字(不带扩展名)，ACB File字段填写ACB文件名字(带扩展名)。例如上图中我已经填了一个示例。
新建一个空物体，然后挂载 CriAtomSource 组件。这个组件，可以理解为Unity的AudioSource，就是用来播声音的。
上图中，CueSheet字段，填写要播放的音源，所在的CueSheet名(不带扩展名)，而CueName，就填写要播放的声音的名字。这些名字，都是做音频的同学定好的。勾选上 Play On Start，然后运行Unity，就可以听到声音。
上面只是实现了声音能够播出来，要在真正的项目中使用，还需要管理声音，下面将说一下大概的思路。
声音管理器 基本思路是这样的，首先有一个声音管理器我们称为AudioManager，提供接口播放声音，停止声音，暂停声音，恢复声音，播放完毕，CueSheet加载卸载。外面模块调用AudioManager去控制声音。
调用 AudioManager 播放声音的接口时，会生成一个新的对象, GameObject，挂载一个脚本，我们称为 AudioPlayer，这个 AudioPlayer 中会动态的挂载 CriAudioSource，然后将我们要播放的CueSheet，CueName这些值通过AudioManager传进去，设置 CriAudioSource 参数，然后调用 CriAudioSource的 Play 函数。
当调用 AudioManager 的播放声音接口时，AudioManager 会动态记录这个 CueSheet 是否已经添加到 CriAtom 中，如果没有，则会添加，这时，CriAtom会去加载声音文件到内存中。
AudioManager 在声音播放完，或者 GameObject 被销毁时，需要调用 AudioManager 的播放完毕接口，用于计数。这个计数，是为了让 AudioManager 知道一个CueSheet中，是否还有声音在播放，如果没有了，则要动态将 CueSheet 从 CriAtom 中移除掉，释放内存。
具体代码我还没写，请等待我有时间再补充~。</description>
    </item>
    
  </channel>
</rss>
