<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>噪声函数与地图生成 | 萌一小栈</title><meta name=keywords content="游戏开发"><meta name=description content="在我学习声音信号处理的时候，我的大脑很自然地联想到了地图生成。这篇博客记录了关于信号处理的一些概念与地图生成相关的东西。这些知识点不是一些新的东西，但对我来说，是以前从未接触过的，所以我想记录一下，并且分享给大家。这篇博客会覆盖一些简单的主题，频率、振幅、噪声的种类、噪声的应用等。涉及到的数学部分，基本上只有正弦波形。
这里会从简单的概念开始，然后逐渐深入。
 注意：下面涉及的代码，虽然是以 Python 来描述的（简单直观），但文章的目的是为了解释原理，使用任何语言都可以的。
 1. 为什么随机性是有用的 我们在程序化的地图生成中要做的是生成一组输出，其中有一些东西是相同的，而有一些东西是不同的。例如，在我的世界这个游戏中，所有的地图都有很多相似性。生物群落，方块大小，生物群落的平均大小，洞穴的平均高度，不同石头所占的比例等等。但是，也有一些不同的地的：群落的位置，黄金的位置，洞穴的大小等等。作为游戏的设计者，需要决定哪些部分需要是相同的，哪些部分需要是不同的。
对于不同的部分，通常是使用随机数生成器。让我们来做一个极其简单的地图生成器：它将包含20个格子，其中某些格子将包含宝箱。结果如下 请注意这个地图有多少共同的地方：首先它都是由格子组成（每个点作为一个格子），每行有20个格子，然后有两种类型的块，一个是空白，一个是宝箱。
但有一点是不同的，哪一个格子是什么类型，也就是说宝箱可能出现在从0到19的任何一个格子。
我们可以使用随机数来选择将宝箱放在哪一个格子中。最简单的方式是选择从0到19的随机数。这意味着每一个格子都可能被选择。大部分的编程语言都包含随机数生成函数。在 Python 中，使用方式是 random.randint(0, 19)。完整代码如下
def gen() 	map = [0] * 20 	pos = random.randint(0, 19) 	map[pos] = 1 	return map  for i in range(5): 	print_chart(i, gen()) 生成结果如下：
假设我们想让地图中的宝箱有更多的可能性出现在左边，这时就要使用非均匀随机数选择了。有很多方法可以完成这件事情，其中一种方式是首先选择一个随机数，然后将它向左移动，例如，使用函数 random(0,19)/2，下面是 Python 代码
def gen(): 	map = [0] * 20 	pos = random.randint(0, 19) / 2 	map[pos] = 1 	return map  for i in range(5): 	print_chart(i, gen()) 然后，如果我们想让宝箱更多地出现在左边，但是，右边也不能一个没有，应该怎么办呢？一个方式是使用平方数，也就是先选定一个随机数，然后计算它的平方，然后再用结果除以19(地图右边界索引)，得到的结果向下取整。下面是代码和效果"><meta name=author content="fred"><link rel=canonical href=https://blog.moeif.com/posts/noise-function-and-map-generation/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=/images/favicon.svg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.moeif.com/images/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://blog.moeif.com/images/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://blog.moeif.com/images/favicon.svg><link rel=apple-touch-icon href=https://blog.moeif.com/favicon.svg><link rel=mask-icon href=https://blog.moeif.com/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.97.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="噪声函数与地图生成"><meta property="og:description" content="在我学习声音信号处理的时候，我的大脑很自然地联想到了地图生成。这篇博客记录了关于信号处理的一些概念与地图生成相关的东西。这些知识点不是一些新的东西，但对我来说，是以前从未接触过的，所以我想记录一下，并且分享给大家。这篇博客会覆盖一些简单的主题，频率、振幅、噪声的种类、噪声的应用等。涉及到的数学部分，基本上只有正弦波形。
这里会从简单的概念开始，然后逐渐深入。
 注意：下面涉及的代码，虽然是以 Python 来描述的（简单直观），但文章的目的是为了解释原理，使用任何语言都可以的。
 1. 为什么随机性是有用的 我们在程序化的地图生成中要做的是生成一组输出，其中有一些东西是相同的，而有一些东西是不同的。例如，在我的世界这个游戏中，所有的地图都有很多相似性。生物群落，方块大小，生物群落的平均大小，洞穴的平均高度，不同石头所占的比例等等。但是，也有一些不同的地的：群落的位置，黄金的位置，洞穴的大小等等。作为游戏的设计者，需要决定哪些部分需要是相同的，哪些部分需要是不同的。
对于不同的部分，通常是使用随机数生成器。让我们来做一个极其简单的地图生成器：它将包含20个格子，其中某些格子将包含宝箱。结果如下 请注意这个地图有多少共同的地方：首先它都是由格子组成（每个点作为一个格子），每行有20个格子，然后有两种类型的块，一个是空白，一个是宝箱。
但有一点是不同的，哪一个格子是什么类型，也就是说宝箱可能出现在从0到19的任何一个格子。
我们可以使用随机数来选择将宝箱放在哪一个格子中。最简单的方式是选择从0到19的随机数。这意味着每一个格子都可能被选择。大部分的编程语言都包含随机数生成函数。在 Python 中，使用方式是 random.randint(0, 19)。完整代码如下
def gen() 	map = [0] * 20 	pos = random.randint(0, 19) 	map[pos] = 1 	return map  for i in range(5): 	print_chart(i, gen()) 生成结果如下：
假设我们想让地图中的宝箱有更多的可能性出现在左边，这时就要使用非均匀随机数选择了。有很多方法可以完成这件事情，其中一种方式是首先选择一个随机数，然后将它向左移动，例如，使用函数 random(0,19)/2，下面是 Python 代码
def gen(): 	map = [0] * 20 	pos = random.randint(0, 19) / 2 	map[pos] = 1 	return map  for i in range(5): 	print_chart(i, gen()) 然后，如果我们想让宝箱更多地出现在左边，但是，右边也不能一个没有，应该怎么办呢？一个方式是使用平方数，也就是先选定一个随机数，然后计算它的平方，然后再用结果除以19(地图右边界索引)，得到的结果向下取整。下面是代码和效果"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.moeif.com/posts/noise-function-and-map-generation/"><meta property="og:image" content="https://blog.moeif.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-25T23:04:23+08:00"><meta property="article:modified_time" content="2022-09-25T23:04:23+08:00"><meta property="og:site_name" content="萌一小栈"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.moeif.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="噪声函数与地图生成"><meta name=twitter:description content="在我学习声音信号处理的时候，我的大脑很自然地联想到了地图生成。这篇博客记录了关于信号处理的一些概念与地图生成相关的东西。这些知识点不是一些新的东西，但对我来说，是以前从未接触过的，所以我想记录一下，并且分享给大家。这篇博客会覆盖一些简单的主题，频率、振幅、噪声的种类、噪声的应用等。涉及到的数学部分，基本上只有正弦波形。
这里会从简单的概念开始，然后逐渐深入。
 注意：下面涉及的代码，虽然是以 Python 来描述的（简单直观），但文章的目的是为了解释原理，使用任何语言都可以的。
 1. 为什么随机性是有用的 我们在程序化的地图生成中要做的是生成一组输出，其中有一些东西是相同的，而有一些东西是不同的。例如，在我的世界这个游戏中，所有的地图都有很多相似性。生物群落，方块大小，生物群落的平均大小，洞穴的平均高度，不同石头所占的比例等等。但是，也有一些不同的地的：群落的位置，黄金的位置，洞穴的大小等等。作为游戏的设计者，需要决定哪些部分需要是相同的，哪些部分需要是不同的。
对于不同的部分，通常是使用随机数生成器。让我们来做一个极其简单的地图生成器：它将包含20个格子，其中某些格子将包含宝箱。结果如下 请注意这个地图有多少共同的地方：首先它都是由格子组成（每个点作为一个格子），每行有20个格子，然后有两种类型的块，一个是空白，一个是宝箱。
但有一点是不同的，哪一个格子是什么类型，也就是说宝箱可能出现在从0到19的任何一个格子。
我们可以使用随机数来选择将宝箱放在哪一个格子中。最简单的方式是选择从0到19的随机数。这意味着每一个格子都可能被选择。大部分的编程语言都包含随机数生成函数。在 Python 中，使用方式是 random.randint(0, 19)。完整代码如下
def gen() 	map = [0] * 20 	pos = random.randint(0, 19) 	map[pos] = 1 	return map  for i in range(5): 	print_chart(i, gen()) 生成结果如下：
假设我们想让地图中的宝箱有更多的可能性出现在左边，这时就要使用非均匀随机数选择了。有很多方法可以完成这件事情，其中一种方式是首先选择一个随机数，然后将它向左移动，例如，使用函数 random(0,19)/2，下面是 Python 代码
def gen(): 	map = [0] * 20 	pos = random.randint(0, 19) / 2 	map[pos] = 1 	return map  for i in range(5): 	print_chart(i, gen()) 然后，如果我们想让宝箱更多地出现在左边，但是，右边也不能一个没有，应该怎么办呢？一个方式是使用平方数，也就是先选定一个随机数，然后计算它的平方，然后再用结果除以19(地图右边界索引)，得到的结果向下取整。下面是代码和效果"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.moeif.com/posts/"},{"@type":"ListItem","position":2,"name":"噪声函数与地图生成","item":"https://blog.moeif.com/posts/noise-function-and-map-generation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"噪声函数与地图生成","name":"噪声函数与地图生成","description":"在我学习声音信号处理的时候，我的大脑很自然地联想到了地图生成。这篇博客记录了关于信号处理的一些概念与地图生成相关的东西。这些知识点不是一些新的东西，但对我来说，是以前从未接触过的，所以我想记录一下，并且分享给大家。这篇博客会覆盖一些简单的主题，频率、振幅、噪声的种类、噪声的应用等。涉及到的数学部分，基本上只有正弦波形。\n这里会从简单的概念开始，然后逐渐深入。\n 注意：下面涉及的代码，虽然是以 Python 来描述的（简单直观），但文章的目的是为了解释原理，使用任何语言都可以的。\n 1. 为什么随机性是有用的 我们在程序化的地图生成中要做的是生成一组输出，其中有一些东西是相同的，而有一些东西是不同的。例如，在我的世界这个游戏中，所有的地图都有很多相似性。生物群落，方块大小，生物群落的平均大小，洞穴的平均高度，不同石头所占的比例等等。但是，也有一些不同的地的：群落的位置，黄金的位置，洞穴的大小等等。作为游戏的设计者，需要决定哪些部分需要是相同的，哪些部分需要是不同的。\n对于不同的部分，通常是使用随机数生成器。让我们来做一个极其简单的地图生成器：它将包含20个格子，其中某些格子将包含宝箱。结果如下 请注意这个地图有多少共同的地方：首先它都是由格子组成（每个点作为一个格子），每行有20个格子，然后有两种类型的块，一个是空白，一个是宝箱。\n但有一点是不同的，哪一个格子是什么类型，也就是说宝箱可能出现在从0到19的任何一个格子。\n我们可以使用随机数来选择将宝箱放在哪一个格子中。最简单的方式是选择从0到19的随机数。这意味着每一个格子都可能被选择。大部分的编程语言都包含随机数生成函数。在 Python 中，使用方式是 random.randint(0, 19)。完整代码如下\ndef gen() \tmap = [0] * 20 \tpos = random.randint(0, 19) \tmap[pos] = 1 \treturn map  for i in range(5): \tprint_chart(i, gen()) 生成结果如下：\n假设我们想让地图中的宝箱有更多的可能性出现在左边，这时就要使用非均匀随机数选择了。有很多方法可以完成这件事情，其中一种方式是首先选择一个随机数，然后将它向左移动，例如，使用函数 random(0,19)/2，下面是 Python 代码\ndef gen(): \tmap = [0] * 20 \tpos = random.randint(0, 19) / 2 \tmap[pos] = 1 \treturn map  for i in range(5): \tprint_chart(i, gen()) 然后，如果我们想让宝箱更多地出现在左边，但是，右边也不能一个没有，应该怎么办呢？一个方式是使用平方数，也就是先选定一个随机数，然后计算它的平方，然后再用结果除以19(地图右边界索引)，得到的结果向下取整。下面是代码和效果","keywords":["游戏开发"],"articleBody":"在我学习声音信号处理的时候，我的大脑很自然地联想到了地图生成。这篇博客记录了关于信号处理的一些概念与地图生成相关的东西。这些知识点不是一些新的东西，但对我来说，是以前从未接触过的，所以我想记录一下，并且分享给大家。这篇博客会覆盖一些简单的主题，频率、振幅、噪声的种类、噪声的应用等。涉及到的数学部分，基本上只有正弦波形。\n这里会从简单的概念开始，然后逐渐深入。\n 注意：下面涉及的代码，虽然是以 Python 来描述的（简单直观），但文章的目的是为了解释原理，使用任何语言都可以的。\n 1. 为什么随机性是有用的 我们在程序化的地图生成中要做的是生成一组输出，其中有一些东西是相同的，而有一些东西是不同的。例如，在我的世界这个游戏中，所有的地图都有很多相似性。生物群落，方块大小，生物群落的平均大小，洞穴的平均高度，不同石头所占的比例等等。但是，也有一些不同的地的：群落的位置，黄金的位置，洞穴的大小等等。作为游戏的设计者，需要决定哪些部分需要是相同的，哪些部分需要是不同的。\n对于不同的部分，通常是使用随机数生成器。让我们来做一个极其简单的地图生成器：它将包含20个格子，其中某些格子将包含宝箱。结果如下 请注意这个地图有多少共同的地方：首先它都是由格子组成（每个点作为一个格子），每行有20个格子，然后有两种类型的块，一个是空白，一个是宝箱。\n但有一点是不同的，哪一个格子是什么类型，也就是说宝箱可能出现在从0到19的任何一个格子。\n我们可以使用随机数来选择将宝箱放在哪一个格子中。最简单的方式是选择从0到19的随机数。这意味着每一个格子都可能被选择。大部分的编程语言都包含随机数生成函数。在 Python 中，使用方式是 random.randint(0, 19)。完整代码如下\ndef gen() \tmap = [0] * 20 \tpos = random.randint(0, 19) \tmap[pos] = 1 \treturn map  for i in range(5): \tprint_chart(i, gen()) 生成结果如下：\n假设我们想让地图中的宝箱有更多的可能性出现在左边，这时就要使用非均匀随机数选择了。有很多方法可以完成这件事情，其中一种方式是首先选择一个随机数，然后将它向左移动，例如，使用函数 random(0,19)/2，下面是 Python 代码\ndef gen(): \tmap = [0] * 20 \tpos = random.randint(0, 19) / 2 \tmap[pos] = 1 \treturn map  for i in range(5): \tprint_chart(i, gen()) 然后，如果我们想让宝箱更多地出现在左边，但是，右边也不能一个没有，应该怎么办呢？一个方式是使用平方数，也就是先选定一个随机数，然后计算它的平方，然后再用结果除以19(地图右边界索引)，得到的结果向下取整。下面是代码和效果\ndef gen(): \tmap = [0] * 20 \tpos = random.randint(0, 19) \tpos = int(pos * pos / 19) \tmap[pos] = 1 \treturn map  for i in range(1, 6): \tprint_chart(i, gen()) 还有一种方法是使用两次随机。第一次先随机选择一个随机数，然后使用得到的这个随机数作为第二次随机的右边界。这样的结果就是假设我们第一次得到的随机数是19，那么最终宝箱的结果可能出现在地图的任何地方。但是，假设第一次得到的随机数是10，那么宝藏的位置，就有更多的可能性偏向左边。代码和效果如下\ndef gen(): \tmap = [0] * 20 \tlimit = random.randint(0, 19) \tpos = random.randint(0, limit) \tmap[pos] = 1 \treturn map  for i in range(5): \tprint_chart(i, gen()) 有很多方式可以将均匀随机数变为非均匀随机数。作为游戏设计者，我们需要根据自己的需求去选择合适的方式。\n2. 什么是噪声 噪声是一系列的随机数，通常分布在一条线上或一个面上。\n在以前老式的电视，如果一个电台没有信号，那么屏幕上就会显示很多黑白的噪点。对于收音机来说，如果没有信息，我们听到的可能就哧哧哧的声音，那也是噪声。\n对于信号处理领域，噪声可理解为干扰正常信号的那些东西。例如在一个房间里有很多人说话，你很想听到特定的一个人在说什么，但是听不清，因为有其他人也在说话，那就是噪声。对于声音处理来说，这种噪声是分布在一条线上，也就是1D的。而在图片处理中，一个图片因为模糊或者很多噪点而看不清原本想要的画面，这种噪声是在一个面上，是一个2D的。当然，也可以有分布于3D，4D的噪声。\n对于很多应用来说，我们尝试减少噪声。但对于自然界来说，很多东西看起来并不是纯粹的，而是充满了一部分噪声。所以，如果想让程序化生成的东西看起来更自然一些，我们需要添加噪声。噪声可以使程序化生成的东西看起来不一样，同时又具有一个基本的可识别结构。这个我们要根据具体的需要来看。\n让我们来看一个使用噪声的例子。在之前，我们是在1D的地力上生成单个宝箱，现在我们想创造一个2D地图，由山谷，丘陵，和山脉组成。这里首先为每一个位置使用一个均匀的随机数选择，也就是 random(1,3)。我们定义1为山谷，2为丘陵，3为山脉。整个2D地图是存放在一个数组中，而每一个格子，存储了生成的随机数。下面是 Python 代码\nfor i in range(5): \trandom.seed(i) \tprint_chart(i, [random.randint(1,3) for i in range()])  这段 Python 代码看不懂也没关系，反正我也看不懂，但是最终其实就是对一个二维数组进行赋值\n 上面的结果看起来太随机了，有时候我们想要不那么均匀的随机，例如，山脉比丘陵更多一点，这种情况，就得使用非均匀随机\nfor i in range(5):  random.seed(i)  print_chart(i, [random.randint(1, random.randint(1, 3))  for i in range(mapsize)]) 上面的非均匀随机对于我们想要的地图结果来说，并没有什么用，因为上面的随机是针对每一个位置，完全独立的随机，而我们想要的，是需要和周围的格子有一定关联的随机。\n现在，该是噪声函数出场的时刻了。噪声函数生成的结果是一个序列，而不是随机函数那样，每次生成的是一个值。噪声函数的定义方式有很多，让我们先试一下最小值函数，也就是取邻近值中最小的那个值。假设原即噪声值数组为（1，5，2）。遍历原即数组，两两比较，取其中最小的时候，也就是先比较（1，5），取1，然后比较（5，2），取2，最终得到的序列为（1，2）。注意，这个噪声函数得到的最终序列元素个数，一定是比原即序列少1个的。将这个噪声函数应用于地图生成，代码如下\ndef adjacent_min(noise): \toutput = [] \tfor i in range(len(noise) - 1): \toutput.append(min(noise[i], noise[i + 1])) \treturn output  for i in range(5): \trandom.seed(i) \tnoise = [random.randint(1, 3) for i in range(mapsize)] \tprint_chart(i, adjacent_min(noise)) 对比之前的生成结果，这个地图上的山谷、丘陵或山脉面积更大。山脉通常在丘陵附近。由于我们使用的噪声函数是最小值，所以山谷比山脉更常见。如果我们采用最大值，则山脉就会比山谷更常见。如果我们想让二者出现次数相当，可以采用平均数，而不是最小或最大值。上面的代码，每一次运行，都将生成不同的结果。\n在程序化生成的过程中，通常做的就是尝试一下，看看结果是否OK，如果不OK，那就改一下代码，再尝试一下。\n 在信号处理中，平滑操作，也就是去掉不想要的噪声，叫做低通过滤器\n 回顾  噪声是一系列随机数的集合，通常是一维或二维的 在程序化生成中，我们通常添加噪声，以此让目标生成物变得不同 使用简单地生成随机数的方式创造噪声，会使每个元素与周围元素完全独立，不相关 我们通常希望噪声拥有一些特性，产生一定的模式 有很多生成噪声的方式 有一些噪声函数是直接生成噪声，而有一些是修改已有的噪声。  选择一个噪声函数有时候靠的是猜测，而了解噪声函数的原理以及如何修改，意味着可以做出更有根据的猜测。\n3. 创造噪声 在之前的内容中，我们使用随机数作为输出，然后对其进行平滑。这一种常见的模式。对于一个随机函数，使用一组随机数作为参数，然后使用另一个随机数，来控制我们想要的内容，例如哪里是宝箱，哪里是山脉，哪里是山丘等等。\n一些1D/2D的噪声生成器：  直接使用随机数作为输出。例如上面的山谷、山丘、山脉 使用随机数作为正弦和余弦的参数，这些参数用于输出 使用随机数作为梯度的参数，这些参数用于输出。这在Simplex/Perlin噪声中使用。  一些常用的修改噪声的方式：  应用一个过滤器来减少或放大某个特征。例如之前我们用平滑法来减少凹凸感，增加山谷的大小，并使山峰出现在山谷附近。 使用两个噪声函数来产生输出，通常会给每一个噪声函数赋予一个权重，以此来控制噪声函数对于输出结果的影响。 对于噪声函数产生的输出结果进行插值，来得到更加平滑的结果。  有很多方式可以创造噪声。从某种程度上来说，噪声如何产生，并不是很重要，但是将噪声用于游戏中，需要关注两件事情\n 你打算如何使用噪声 你希望从噪声函数中获得什么属性  4. 使用噪声的方式 使用噪声最直接的方式是作为海拔高度。在之前的例子中，我们使用 random(1,3) 来产生1、2、3这三个数，分别对应山谷、山丘、山脉。这是直接使用。\n使用中点位移噪声或Simplex/Perlin噪声作为海拔，也是直接使用。\n另一种使用噪声的方式是应用于移动中，简单来说就是下一步的移动，取决于上一步。例如一个噪声函数输出的值是 [2, -1, 5] 这可以表示为初始位置为2，然后移动，2 + -1 = 1，然后再移动 1 + 5 = 6，也就是最终走到了6的位置。\n除了将噪声作为海拔高度外，还可能将它用于音频。\n或者你要用它来做一个形状。例如，你可以在极坐标图中使用噪声作为半径。你可以把这样的一维噪声函数转换成极坐标形式，把输出作为半径而不是作为海拔。下面是同样的函数在极地形式下的样子。\n或者你可能使用噪声作为图形纹理。Simplex/Perlin噪声经常被用于此。\n你可以用噪音来选择物体的位置，如树木或金矿或火山或地震断层线。在前面的例子中，我用一个随机数来选择宝箱的位置。\n你可以用噪声作为阈值函数。例如，你可以说，任何时候数值大于3，那么就会发生一件事，否则就会发生其他事情。这方面的一个例子是使用3D Simplex/Perlin噪声来生成洞穴。你可以说，任何高于某个密度阈值的东西都是不可行走的区域，任何低于该阈值的东西都是开放的空间（洞穴）。\n5. 噪声的频率 频率是噪声的一个主要属性，最简单理解方式是直接看图，例如下面是正弦波的三种不同的频率，低频率，中频率，高频率的波形。\n从上面三种不同的频率可以看出，低频率会使起伏更平缓，范围更大，则高频率会使起伏更尖锐。频率描述的是横向的属性。而振幅描述的是纵向的属性。在之前的例子中，山丘，山谷，山脉，看起来太过于『随机』了，意思就是我们需要更低一点的随机频率，来降低这种随机性，使其更加的缓和。\n如果我们使用一个连续的噪声生成函数，增加频率，意味着输入参数的变化。而增加振幅，则意味着是对噪声函数产生的结果进行增量改变。假设噪声函数就是 sin(x)。增加频率，也就是 sin(x * 2) 则是两倍的频率。而增加振幅，则是 2 * sin(x)。\n对于上面的图来说，改变的是频率，增大频率，意味着一个一个的波峰数量，频率越高，则两个波峰越多，两个波峰之间的距离越小。\n对于上面的图来说，改变的是振幅，增加振幅，不会增加波峰的数量 ，而会改变波峰的高度。\n上面的内容都是针对1D噪声的，对于2D噪声，也是同样的原理。\n对于正弦波，我们还可以使用各种奇怪的组合，以此产生不同的效果。例如下面的这个例子，就是左边的频率更低一点，而右边的频率更高一点\n通常来说，在同一时刻，可以使用多种不同频率的噪声，没有什么标准的规则，主要是看自己的需求，想要什么样的东西，然后再看怎么使用噪声。\n6. 噪声的种类 不同种类的噪声拥有不同的频率。对于白噪声来说，所有的频率对于结果的贡献度，也可以说是权重，是一样的。例如我们前面的例子，使用1，2，3来代表山脉，山谷，丘陵。下面是条白噪声序列\n在红色噪声，也称为布朗噪声中，低频会更加的突出。也就是说，会有更长的山谷和山丘。我们可以通过平均两个相邻随机数的形式，将白噪声变为布朗噪声。\ndef smoother(noise): \toutput = [] \tfor i in range(len(noise) - 1): \toutput.append(0.5 * (noise[i] + noise[i + 1])) \treturn output  for i in range(8): \trandom.seed(i) \tnoise = [random.uniform(-1, +1) for i in range(mapsize)] \tprint_chart(i, smoother(noise)) 粉红噪声界于白噪声和布朗噪声之间，在自然界中也更常见。\n在频谱的另一边，是蓝色噪声，高频会更加突出。我们可以使用白噪声中两个随机数之差，来产生蓝色噪声。\ndef rougher(noise): \toutput = [] \tfor i in range(len(noise) - 1): \toutput.append(0.5 * (noise[i] - noise[i + 1])) \treturn output  for i in range(8): \trandom.seed(i) \tnoise = [random.uniform(-1, +1) for i in range(mapsize)] \tprint_chart(i, rougher(noise)) 蓝色噪声可以用于地图中放置物体，它产生的结果不会很密集或者很稀疏，物体在地图中的分布整体比较均匀。\n上面的内容我们已经了解了如何产生白噪声，布朗噪声，蓝色噪声，后面我们还会一起探究更多类型的噪声。\n回顾  频率是一种重复的信号。 白噪声是最简单的，它是均匀地选择随机数。 红，粉，蓝等噪声在程序化生成中很有用。 将白噪声变为布朗噪声，可以使用相邻随机数的 + 操作 将白噪声变为蓝色噪声，可以使用相邻随机数的 - 操作  7. 组合频率 在之前的内容中我们了解了不同类型的噪声的特点。另一种生成噪声的方式是组合不同频率的噪声。例如，假设我们有一个噪声函数 noise ，会在特定的频率 freq 生成噪声。如果你想让 1000Hz 的噪声比 2000Hz 的噪声强一倍，并且没有其他频率的噪声，那么我们可以这样来生成 noise(1000) + 0.5 * noise(2000)\n正弦函数看起来并不是很嘈杂，但是这个函数很容易给定一个频率，所以我先从正弦开始，然后一步一步往前走。\ndef noise(freq): \tphase = random.uniform(0, 2 * math.pi) \treturn [math.sin(2 * math.pi * freq * x / mapsize + phase) \tfor x in range(mapsize)]  for i in range(3): \trandom.seed(i) \tprint_chart(i, noise(1)) 上面的结果，是把一个基础的正弦波使用一个随机量来控制其向侧面位移。这里唯一的随机性，是将它移的有多远。\n接下来我们尝试将8个噪声函数加在一起，频率分别是 1，2，4，8，16，32。每一个噪声函数将乘以一个因子，可以理解为不同频率的权重。\ndef weighted_sum(amplitudes, noises): \toutput = [0.0] * mapsize \tfor k in range(len(noises)): \tfor x in range(mapsize): \toutput[x] += amplitudes[k] * noise[k][x] \treturn output  amplitudes = [0.2, 0.5, 1.0, 0.7, 0.5, 0.4] frequencies = [1,2,4,8,16,32]  for i in range(10): \trandom.seed(i) \tnoises = [noise(f) for f in frequencies] \tsum_of_noises = weighted_sum(amplitudes, noises) \tprint_chart(i, sum_of_noises) 如果我们改变权重因子，也就是 amplitudes 数组，得到的结果就会不同。假设将 amplitudes 改为 [1.0, 0.7, 0.5, 0.3, 0.2, 0.1]，则得到的结果如下\n而改为 [0.1, 0.1, 0.2, 0.3, 0.5, 1.0]，则结果如下 ","wordCount":"477","inLanguage":"en","datePublished":"2022-09-25T23:04:23+08:00","dateModified":"2022-09-25T23:04:23+08:00","author":{"@type":"Person","name":"fred"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.moeif.com/posts/noise-function-and-map-generation/"},"publisher":{"@type":"Organization","name":"萌一小栈","logo":{"@type":"ImageObject","url":"https://blog.moeif.com/images/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.moeif.com/ accesskey=h title="Moeif (Alt + H)"><img src=/images/favicon.svg alt=logo aria-label=logo height=35>Moeif</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.moeif.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.moeif.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.moeif.com/about/ title=About><span>About</span></a></li><li><a href=https://blog.moeif.com/weekly/ title=Weekly><span>Weekly</span></a></li><li><a href=https://moeif.com title="Moeif Games"><span>Moeif Games</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.moeif.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.moeif.com/posts/>Posts</a></div><h1 class=post-title>噪声函数与地图生成</h1><div class=post-meta><span title="2022-09-25 23:04:23 +0800 CST">September 25, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;fred</div></header><div class=post-content><p>在我学习声音信号处理的时候，我的大脑很自然地联想到了地图生成。这篇博客记录了关于信号处理的一些概念与地图生成相关的东西。这些知识点不是一些新的东西，但对我来说，是以前从未接触过的，所以我想记录一下，并且分享给大家。这篇博客会覆盖一些简单的主题，频率、振幅、噪声的种类、噪声的应用等。涉及到的数学部分，基本上只有正弦波形。</p><p>这里会从简单的概念开始，然后逐渐深入。</p><blockquote><p>注意：下面涉及的代码，虽然是以 Python 来描述的（简单直观），但文章的目的是为了解释原理，使用任何语言都可以的。</p></blockquote><h2 id=1-为什么随机性是有用的>1. 为什么随机性是有用的<a hidden class=anchor aria-hidden=true href=#1-为什么随机性是有用的>#</a></h2><p>我们在程序化的地图生成中要做的是生成一组输出，其中有一些东西是相同的，而有一些东西是不同的。例如，在我的世界这个游戏中，所有的地图都有很多相似性。生物群落，方块大小，生物群落的平均大小，洞穴的平均高度，不同石头所占的比例等等。但是，也有一些不同的地的：群落的位置，黄金的位置，洞穴的大小等等。作为游戏的设计者，需要决定哪些部分需要是相同的，哪些部分需要是不同的。</p><p>对于不同的部分，通常是使用随机数生成器。让我们来做一个极其简单的地图生成器：它将包含20个格子，其中某些格子将包含宝箱。结果如下
<img loading=lazy src=/postimages/noise-function-and-map-generation/20220903194217.png alt>
请注意这个地图有多少共同的地方：首先它都是由格子组成（每个点作为一个格子），每行有20个格子，然后有两种类型的块，一个是空白，一个是宝箱。</p><p>但有一点是不同的，哪一个格子是什么类型，也就是说宝箱可能出现在从0到19的任何一个格子。</p><p>我们可以使用随机数来选择将宝箱放在哪一个格子中。最简单的方式是选择从0到19的随机数。这意味着每一个格子都可能被选择。大部分的编程语言都包含随机数生成函数。在 Python 中，使用方式是 <code>random.randint(0, 19)</code>。完整代码如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gen</span>()
</span></span><span style=display:flex><span>	map <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>	pos <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>19</span>)
</span></span><span style=display:flex><span>	map[pos] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> map
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>	print_chart(i, gen())
</span></span></code></pre></div><p>生成结果如下：</p><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220903195719.png alt>
假设我们想让地图中的宝箱有更多的可能性出现在左边，这时就要使用非均匀随机数选择了。有很多方法可以完成这件事情，其中一种方式是首先选择一个随机数，然后将它向左移动，例如，使用函数 <code>random(0,19)/2</code>，下面是 Python 代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gen</span>():
</span></span><span style=display:flex><span>	map <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>	pos <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>19</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	map[pos] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> map
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>	print_chart(i, gen())
</span></span></code></pre></div><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220905084311.png alt></p><p>然后，如果我们想让宝箱更多地出现在左边，但是，右边也不能一个没有，应该怎么办呢？一个方式是使用平方数，也就是先选定一个随机数，然后计算它的平方，然后再用结果除以19(地图右边界索引)，得到的结果向下取整。下面是代码和效果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gen</span>():
</span></span><span style=display:flex><span>	map <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>	pos <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>19</span>)
</span></span><span style=display:flex><span>	pos <span style=color:#f92672>=</span> int(pos <span style=color:#f92672>*</span> pos <span style=color:#f92672>/</span> <span style=color:#ae81ff>19</span>)
</span></span><span style=display:flex><span>	map[pos] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> map
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>6</span>):
</span></span><span style=display:flex><span>	print_chart(i, gen())
</span></span></code></pre></div><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220905085131.png alt></p><p>还有一种方法是使用两次随机。第一次先随机选择一个随机数，然后使用得到的这个随机数作为第二次随机的右边界。这样的结果就是假设我们第一次得到的随机数是19，那么最终宝箱的结果可能出现在地图的任何地方。但是，假设第一次得到的随机数是10，那么宝藏的位置，就有更多的可能性偏向左边。代码和效果如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gen</span>():
</span></span><span style=display:flex><span>	map <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>	limit <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>19</span>)
</span></span><span style=display:flex><span>	pos <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, limit)
</span></span><span style=display:flex><span>	map[pos] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> map
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>	print_chart(i, gen())
</span></span></code></pre></div><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220905085415.png alt></p><p>有很多方式可以将均匀随机数变为非均匀随机数。作为游戏设计者，我们需要根据自己的需求去选择合适的方式。</p><h2 id=2-什么是噪声>2. 什么是噪声<a hidden class=anchor aria-hidden=true href=#2-什么是噪声>#</a></h2><p>噪声是一系列的随机数，通常分布在一条线上或一个面上。</p><p>在以前老式的电视，如果一个电台没有信号，那么屏幕上就会显示很多黑白的噪点。对于收音机来说，如果没有信息，我们听到的可能就哧哧哧的声音，那也是噪声。</p><p>对于信号处理领域，噪声可理解为干扰正常信号的那些东西。例如在一个房间里有很多人说话，你很想听到特定的一个人在说什么，但是听不清，因为有其他人也在说话，那就是噪声。对于声音处理来说，这种噪声是分布在一条线上，也就是1D的。而在图片处理中，一个图片因为模糊或者很多噪点而看不清原本想要的画面，这种噪声是在一个面上，是一个2D的。当然，也可以有分布于3D，4D的噪声。</p><p>对于很多应用来说，我们尝试减少噪声。但对于自然界来说，很多东西看起来并不是纯粹的，而是充满了一部分噪声。所以，如果想让程序化生成的东西看起来更自然一些，我们需要添加噪声。噪声可以使程序化生成的东西看起来不一样，同时又具有一个基本的可识别结构。这个我们要根据具体的需要来看。</p><p>让我们来看一个使用噪声的例子。在之前，我们是在1D的地力上生成单个宝箱，现在我们想创造一个2D地图，由山谷，丘陵，和山脉组成。这里首先为每一个位置使用一个均匀的随机数选择，也就是 <code>random(1,3)</code>。我们定义1为山谷，2为丘陵，3为山脉。整个2D地图是存放在一个数组中，而每一个格子，存储了生成的随机数。下面是 Python 代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>	random<span style=color:#f92672>.</span>seed(i)
</span></span><span style=display:flex><span>	print_chart(i, [random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range()])
</span></span></code></pre></div><blockquote><p>这段 Python 代码看不懂也没关系，反正我也看不懂，但是最终其实就是对一个二维数组进行赋值</p></blockquote><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220906112019.png alt></p><p>上面的结果看起来太随机了，有时候我们想要不那么均匀的随机，例如，山脉比丘陵更多一点，这种情况，就得使用非均匀随机</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>    random<span style=color:#f92672>.</span>seed(i)
</span></span><span style=display:flex><span>    print_chart(i, [random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>1</span>, random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>)) 
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(mapsize)])
</span></span></code></pre></div><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220907193058.png alt></p><p>上面的非均匀随机对于我们想要的地图结果来说，并没有什么用，因为上面的随机是针对每一个位置，完全独立的随机，而我们想要的，是需要和周围的格子有一定关联的随机。</p><p>现在，该是噪声函数出场的时刻了。噪声函数生成的结果是一个序列，而不是随机函数那样，每次生成的是一个值。噪声函数的定义方式有很多，让我们先试一下最小值函数，也就是取邻近值中最小的那个值。假设原即噪声值数组为（1，5，2）。遍历原即数组，两两比较，取其中最小的时候，也就是先比较（1，5），取1，然后比较（5，2），取2，最终得到的序列为（1，2）。注意，这个噪声函数得到的最终序列元素个数，一定是比原即序列少1个的。将这个噪声函数应用于地图生成，代码如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>adjacent_min</span>(noise):
</span></span><span style=display:flex><span>	output <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(noise) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>		output<span style=color:#f92672>.</span>append(min(noise[i], noise[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> output
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>	random<span style=color:#f92672>.</span>seed(i)
</span></span><span style=display:flex><span>	noise <span style=color:#f92672>=</span> [random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(mapsize)]
</span></span><span style=display:flex><span>	print_chart(i, adjacent_min(noise))
</span></span></code></pre></div><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220907212942.png alt></p><p>对比之前的生成结果，这个地图上的山谷、丘陵或山脉面积更大。山脉通常在丘陵附近。由于我们使用的噪声函数是最小值，所以山谷比山脉更常见。如果我们采用最大值，则山脉就会比山谷更常见。如果我们想让二者出现次数相当，可以采用平均数，而不是最小或最大值。上面的代码，每一次运行，都将生成不同的结果。</p><p>在程序化生成的过程中，通常做的就是尝试一下，看看结果是否OK，如果不OK，那就改一下代码，再尝试一下。</p><blockquote><p>在信号处理中，平滑操作，也就是去掉不想要的噪声，叫做低通过滤器</p></blockquote><h3 id=回顾>回顾<a hidden class=anchor aria-hidden=true href=#回顾>#</a></h3><ul><li>噪声是一系列随机数的集合，通常是一维或二维的</li><li>在程序化生成中，我们通常添加噪声，以此让目标生成物变得不同</li><li>使用简单地生成随机数的方式创造噪声，会使每个元素与周围元素完全独立，不相关</li><li>我们通常希望噪声拥有一些特性，产生一定的模式</li><li>有很多生成噪声的方式</li><li>有一些噪声函数是直接生成噪声，而有一些是修改已有的噪声。</li></ul><p>选择一个噪声函数有时候靠的是猜测，而了解噪声函数的原理以及如何修改，意味着可以做出更有根据的猜测。</p><h2 id=3-创造噪声>3. 创造噪声<a hidden class=anchor aria-hidden=true href=#3-创造噪声>#</a></h2><p>在之前的内容中，我们使用随机数作为输出，然后对其进行平滑。这一种常见的模式。对于一个随机函数，使用一组随机数作为参数，然后使用另一个随机数，来控制我们想要的内容，例如哪里是宝箱，哪里是山脉，哪里是山丘等等。</p><h3 id=一些1d2d的噪声生成器>一些1D/2D的噪声生成器：<a hidden class=anchor aria-hidden=true href=#一些1d2d的噪声生成器>#</a></h3><ul><li>直接使用随机数作为输出。例如上面的山谷、山丘、山脉</li><li>使用随机数作为正弦和余弦的参数，这些参数用于输出</li><li>使用随机数作为梯度的参数，这些参数用于输出。这在Simplex/Perlin噪声中使用。</li></ul><h3 id=一些常用的修改噪声的方式>一些常用的修改噪声的方式：<a hidden class=anchor aria-hidden=true href=#一些常用的修改噪声的方式>#</a></h3><ul><li>应用一个过滤器来减少或放大某个特征。例如之前我们用平滑法来减少凹凸感，增加山谷的大小，并使山峰出现在山谷附近。</li><li>使用两个噪声函数来产生输出，通常会给每一个噪声函数赋予一个权重，以此来控制噪声函数对于输出结果的影响。</li><li>对于噪声函数产生的输出结果进行插值，来得到更加平滑的结果。</li></ul><p>有很多方式可以创造噪声。从某种程度上来说，噪声如何产生，并不是很重要，但是将噪声用于游戏中，需要关注两件事情</p><ul><li>你打算如何使用噪声</li><li>你希望从噪声函数中获得什么属性</li></ul><h2 id=4-使用噪声的方式>4. 使用噪声的方式<a hidden class=anchor aria-hidden=true href=#4-使用噪声的方式>#</a></h2><p>使用噪声最直接的方式是作为海拔高度。在之前的例子中，我们使用 <code>random(1,3)</code> 来产生1、2、3这三个数，分别对应山谷、山丘、山脉。这是直接使用。</p><p>使用中点位移噪声或Simplex/Perlin噪声作为海拔，也是直接使用。</p><p>另一种使用噪声的方式是应用于移动中，简单来说就是下一步的移动，取决于上一步。例如一个噪声函数输出的值是 [2, -1, 5] 这可以表示为初始位置为2，然后移动，2 + -1 = 1，然后再移动 1 + 5 = 6，也就是最终走到了6的位置。</p><p>除了将噪声作为海拔高度外，还可能将它用于音频。</p><p>或者你要用它来做一个形状。例如，你可以在极坐标图中使用噪声作为半径。你可以把这样的一维噪声函数转换成极坐标形式，把输出作为半径而不是作为海拔。下面是同样的函数在极地形式下的样子。</p><p>或者你可能使用噪声作为图形纹理。Simplex/Perlin噪声经常被用于此。</p><p>你可以用噪音来选择物体的位置，如树木或金矿或火山或地震断层线。在前面的例子中，我用一个随机数来选择宝箱的位置。</p><p>你可以用噪声作为阈值函数。例如，你可以说，任何时候数值大于3，那么就会发生一件事，否则就会发生其他事情。这方面的一个例子是使用3D Simplex/Perlin噪声来生成洞穴。你可以说，任何高于某个密度阈值的东西都是不可行走的区域，任何低于该阈值的东西都是开放的空间（洞穴）。</p><h2 id=5-噪声的频率>5. 噪声的频率<a hidden class=anchor aria-hidden=true href=#5-噪声的频率>#</a></h2><p>频率是噪声的一个主要属性，最简单理解方式是直接看图，例如下面是正弦波的三种不同的频率，低频率，中频率，高频率的波形。</p><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914140133.png alt></p><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914140146.png alt></p><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914140200.png alt></p><p>从上面三种不同的频率可以看出，低频率会使起伏更平缓，范围更大，则高频率会使起伏更尖锐。频率描述的是横向的属性。而振幅描述的是纵向的属性。在之前的例子中，山丘，山谷，山脉，看起来太过于『随机』了，意思就是我们需要更低一点的随机频率，来降低这种随机性，使其更加的缓和。</p><p>如果我们使用一个连续的噪声生成函数，增加频率，意味着输入参数的变化。而增加振幅，则意味着是对噪声函数产生的结果进行增量改变。假设噪声函数就是 sin(x)。增加频率，也就是 <code>sin(x * 2)</code> 则是两倍的频率。而增加振幅，则是 <code>2 * sin(x)</code>。</p><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914140906.png alt>
<img loading=lazy src=/postimages/noise-function-and-map-generation/20220914141054.png alt>
对于上面的图来说，改变的是频率，增大频率，意味着一个一个的波峰数量，频率越高，则两个波峰越多，两个波峰之间的距离越小。</p><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914140945.png alt>
<img loading=lazy src=/postimages/noise-function-and-map-generation/20220914141039.png alt>
对于上面的图来说，改变的是振幅，增加振幅，不会增加波峰的数量 ，而会改变波峰的高度。</p><p>上面的内容都是针对1D噪声的，对于2D噪声，也是同样的原理。</p><p>对于正弦波，我们还可以使用各种奇怪的组合，以此产生不同的效果。例如下面的这个例子，就是左边的频率更低一点，而右边的频率更高一点</p><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914141425.png alt></p><p>通常来说，在同一时刻，可以使用多种不同频率的噪声，没有什么标准的规则，主要是看自己的需求，想要什么样的东西，然后再看怎么使用噪声。</p><h2 id=6-噪声的种类>6. 噪声的种类<a hidden class=anchor aria-hidden=true href=#6-噪声的种类>#</a></h2><p>不同种类的噪声拥有不同的频率。对于白噪声来说，所有的频率对于结果的贡献度，也可以说是权重，是一样的。例如我们前面的例子，使用1，2，3来代表山脉，山谷，丘陵。下面是条白噪声序列</p><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914141920.png alt></p><p>在红色噪声，也称为布朗噪声中，低频会更加的突出。也就是说，会有更长的山谷和山丘。我们可以通过平均两个相邻随机数的形式，将白噪声变为布朗噪声。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>smoother</span>(noise):
</span></span><span style=display:flex><span>	output <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(noise) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>		output<span style=color:#f92672>.</span>append(<span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> (noise[i] <span style=color:#f92672>+</span> noise[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> output
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>8</span>):
</span></span><span style=display:flex><span>	random<span style=color:#f92672>.</span>seed(i)
</span></span><span style=display:flex><span>	noise <span style=color:#f92672>=</span> [random<span style=color:#f92672>.</span>uniform(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(mapsize)]
</span></span><span style=display:flex><span>	print_chart(i, smoother(noise))
</span></span></code></pre></div><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914142405.png alt></p><p>粉红噪声界于白噪声和布朗噪声之间，在自然界中也更常见。</p><p>在频谱的另一边，是蓝色噪声，高频会更加突出。我们可以使用白噪声中两个随机数之差，来产生蓝色噪声。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rougher</span>(noise):
</span></span><span style=display:flex><span>	output <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(noise) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>		output<span style=color:#f92672>.</span>append(<span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> (noise[i] <span style=color:#f92672>-</span> noise[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> output
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>8</span>):
</span></span><span style=display:flex><span>	random<span style=color:#f92672>.</span>seed(i)
</span></span><span style=display:flex><span>	noise <span style=color:#f92672>=</span> [random<span style=color:#f92672>.</span>uniform(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(mapsize)]
</span></span><span style=display:flex><span>	print_chart(i, rougher(noise))
</span></span></code></pre></div><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914142956.png alt></p><p>蓝色噪声可以用于地图中放置物体，它产生的结果不会很密集或者很稀疏，物体在地图中的分布整体比较均匀。</p><p>上面的内容我们已经了解了如何产生白噪声，布朗噪声，蓝色噪声，后面我们还会一起探究更多类型的噪声。</p><h3 id=回顾-1>回顾<a hidden class=anchor aria-hidden=true href=#回顾-1>#</a></h3><ul><li>频率是一种重复的信号。</li><li>白噪声是最简单的，它是均匀地选择随机数。</li><li>红，粉，蓝等噪声在程序化生成中很有用。</li><li>将白噪声变为布朗噪声，可以使用相邻随机数的 + 操作</li><li>将白噪声变为蓝色噪声，可以使用相邻随机数的 - 操作</li></ul><h2 id=7-组合频率>7. 组合频率<a hidden class=anchor aria-hidden=true href=#7-组合频率>#</a></h2><p>在之前的内容中我们了解了不同类型的噪声的特点。另一种生成噪声的方式是组合不同频率的噪声。例如，假设我们有一个噪声函数 <code>noise</code> ，会在特定的频率 <code>freq</code> 生成噪声。如果你想让 1000Hz 的噪声比 2000Hz 的噪声强一倍，并且没有其他频率的噪声，那么我们可以这样来生成 <code>noise(1000) + 0.5 * noise(2000)</code></p><p>正弦函数看起来并不是很嘈杂，但是这个函数很容易给定一个频率，所以我先从正弦开始，然后一步一步往前走。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>noise</span>(freq):
</span></span><span style=display:flex><span>	phase <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>uniform(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> math<span style=color:#f92672>.</span>pi)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> [math<span style=color:#f92672>.</span>sin(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> math<span style=color:#f92672>.</span>pi <span style=color:#f92672>*</span> freq <span style=color:#f92672>*</span> x <span style=color:#f92672>/</span> mapsize <span style=color:#f92672>+</span> phase)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(mapsize)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>3</span>):
</span></span><span style=display:flex><span>	random<span style=color:#f92672>.</span>seed(i)
</span></span><span style=display:flex><span>	print_chart(i, noise(<span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914144931.png alt></p><p>上面的结果，是把一个基础的正弦波使用一个随机量来控制其向侧面位移。这里唯一的随机性，是将它移的有多远。</p><p>接下来我们尝试将8个噪声函数加在一起，频率分别是 1，2，4，8，16，32。每一个噪声函数将乘以一个因子，可以理解为不同频率的权重。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>weighted_sum</span>(amplitudes, noises):
</span></span><span style=display:flex><span>	output <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0.0</span>] <span style=color:#f92672>*</span> mapsize
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(len(noises)):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(mapsize):
</span></span><span style=display:flex><span>			output[x] <span style=color:#f92672>+=</span> amplitudes[k] <span style=color:#f92672>*</span> noise[k][x]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> output
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>amplitudes <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.7</span>, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0.4</span>]
</span></span><span style=display:flex><span>frequencies <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>16</span>,<span style=color:#ae81ff>32</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
</span></span><span style=display:flex><span>	random<span style=color:#f92672>.</span>seed(i)
</span></span><span style=display:flex><span>	noises <span style=color:#f92672>=</span> [noise(f) <span style=color:#66d9ef>for</span> f <span style=color:#f92672>in</span> frequencies]
</span></span><span style=display:flex><span>	sum_of_noises <span style=color:#f92672>=</span> weighted_sum(amplitudes, noises)
</span></span><span style=display:flex><span>	print_chart(i, sum_of_noises)
</span></span></code></pre></div><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914145756.png alt></p><p>如果我们改变权重因子，也就是 amplitudes 数组，得到的结果就会不同。假设将 amplitudes 改为 <code>[1.0, 0.7, 0.5, 0.3, 0.2, 0.1]</code>，则得到的结果如下</p><p><img loading=lazy src=/postimages/noise-function-and-map-generation/20220914145910.png alt></p><p>而改为 <code>[0.1, 0.1, 0.2, 0.3, 0.5, 1.0]</code>，则结果如下
<img loading=lazy src=/postimages/noise-function-and-map-generation/20220914145935.png alt></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.moeif.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/>游戏开发</a></li></ul><nav class=paginav><a class=next href=https://blog.moeif.com/posts/show-privacy-before-unity/><span class=title>Next Page »</span><br><span>Unity 游戏启动前显示隐私协议</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 噪声函数与地图生成 on twitter" href="https://twitter.com/intent/tweet/?text=%e5%99%aa%e5%a3%b0%e5%87%bd%e6%95%b0%e4%b8%8e%e5%9c%b0%e5%9b%be%e7%94%9f%e6%88%90&url=https%3a%2f%2fblog.moeif.com%2fposts%2fnoise-function-and-map-generation%2f&hashtags=%e6%b8%b8%e6%88%8f%e5%bc%80%e5%8f%91"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 噪声函数与地图生成 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.moeif.com%2fposts%2fnoise-function-and-map-generation%2f&title=%e5%99%aa%e5%a3%b0%e5%87%bd%e6%95%b0%e4%b8%8e%e5%9c%b0%e5%9b%be%e7%94%9f%e6%88%90&summary=%e5%99%aa%e5%a3%b0%e5%87%bd%e6%95%b0%e4%b8%8e%e5%9c%b0%e5%9b%be%e7%94%9f%e6%88%90&source=https%3a%2f%2fblog.moeif.com%2fposts%2fnoise-function-and-map-generation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 噪声函数与地图生成 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.moeif.com%2fposts%2fnoise-function-and-map-generation%2f&title=%e5%99%aa%e5%a3%b0%e5%87%bd%e6%95%b0%e4%b8%8e%e5%9c%b0%e5%9b%be%e7%94%9f%e6%88%90"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 噪声函数与地图生成 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.moeif.com%2fposts%2fnoise-function-and-map-generation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 噪声函数与地图生成 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%99%aa%e5%a3%b0%e5%87%bd%e6%95%b0%e4%b8%8e%e5%9c%b0%e5%9b%be%e7%94%9f%e6%88%90%20-%20https%3a%2f%2fblog.moeif.com%2fposts%2fnoise-function-and-map-generation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 噪声函数与地图生成 on telegram" href="https://telegram.me/share/url?text=%e5%99%aa%e5%a3%b0%e5%87%bd%e6%95%b0%e4%b8%8e%e5%9c%b0%e5%9b%be%e7%94%9f%e6%88%90&url=https%3a%2f%2fblog.moeif.com%2fposts%2fnoise-function-and-map-generation%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?da9253be08586e454189323668956d43",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-7X4M6RGQGH"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7X4M6RGQGH")</script></body></html>